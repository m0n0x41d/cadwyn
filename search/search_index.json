{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cadwyn","text":"<p>Production-ready community-driven modern Stripe-like API versioning in FastAPI</p> <p> </p>"},{"location":"#who-is-this-for","title":"Who is this for?","text":"<p>Cadwyn allows you to support a single version of your code while auto-generating the schemas and routes for older versions. You keep API versioning encapsulated in small and independent \"version change\" modules while your business logic stays simple and knows nothing about versioning.</p> <p>Its approach will be useful if you want to:</p> <ol> <li>Support many API versions for a long time</li> <li>Effortlessly backport features and bugfixes to older API versions</li> </ol> <p>Whether you are a newbie in API versioning, a pro looking for a sophisticated tool, an experimenter looking to build a similar framework, or even someone who just wants to learn about all approaches to API versioning -- Cadwyn has the functionality, theory, and documentation to cover all the mentioned use cases.</p>"},{"location":"#get-started","title":"Get started","text":"<p>It is recommended to read the quickstart tutorial first to get your feet wet with Cadwyn's approach</p>"},{"location":"#sponsors","title":"Sponsors","text":"<p>These are our gorgeous sponsors. They are using Cadwyn and are sponsoring it through various means. Contact me if you would like to become one too!</p> <p></p>"},{"location":"concepts/","title":"Concepts","text":"<p>This section covers the entirety of features and their rationale in Cadwyn. It can also be used as a reference documentation until we have a proper one. First, let's talk about the reasons for using Cadwyn at all.</p> <p>Cadwyn aims to be the most accurate and sophisticated API Versioning model out there. First of all, you maintain zero duplicated code yourself. Usually, in API versioning you would need to duplicate and maintain at least some layer of your applicaton. It could be the database, business logic, schemas, and endpoints. Cadwyn only duplicates your:</p> <ul> <li>schemas but you do not maintain the duplicates -- you only regenerate it when necessary</li> <li>endpoints but only in runtime so you do not need to maintain the duplicates</li> </ul> <p>You define your database, business logic, routes, and schemas only once. Then, whenever you release a new API version, you use Cadwyn's version change DSL to describe how to convert your app to the previous version. So your business logic and database stay intact and always represent the latest version while the version changes make sure that your clients can continue using the previous versions without ever needing to update their code.</p> <p>This allows you to effortlessly maintain hundreds of versions, unlike any other API versioning approach.</p>"},{"location":"concepts/api_version_header_and_context_variables/","title":"API Version header and context variables","text":"<p>Cadwyn automatically converts your data to a correct version and has \"version checks\" when dealing with side effects as described in the section above. It can only do so using a special context variable that stores the current API version.</p> <p>You can also pass a different compatible contextvar to your <code>cadwyn.VersionBundle</code> constructor.</p>"},{"location":"concepts/beware_of_data_versioning/","title":"Beware of data versioning","text":"<p>Oftentimes you will want to introduce a breaking change where one of the following is true:</p> <ul> <li>Old data cannot be automatically converted to the structure of the new response</li> <li>New response cannot be automatically migrated to an older response</li> <li>Old request cannot be automatically converted to the HEAD request</li> </ul> <p>This means that you are not versioning your API, you are versioning your data. This is not and cannot be solved by an API versioning framework. It also makes it incredibly hard to version as you now cannot guarantee compatibility between versions. Avoid this at all costs -- all your API versions must be compatible between each other. Data versioning is not a result of a complicated use case, it is a result of errors when divising a new version. I am yet to meet a single case where data versioning is the right way to solve an API versioning problem.</p>"},{"location":"concepts/cli/","title":"CLI","text":"<p>Cadwyn has an optional CLI interface that can be installed with <code>pip install cadwyn[cli]</code>. You can run <code>cadwyn --version</code> to check current version of Cadwyn.</p> <p>Its main purpose is code generation.</p>"},{"location":"concepts/code_generation/","title":"Code generation","text":"<p>Cadwyn generates versioned schemas and everything related to them from latest version. These versioned schemas will be automatically used in requests and responses for versioned API routes. There are two methods of generating code: using a function and using the CLI:</p>"},{"location":"concepts/code_generation/#command-line-interface","title":"Command-line interface","text":"<p>You can use <code>cadwyn codegen</code> which accepts a python path to your version bundle.</p> <p>NOTE that it is not a regular system path. It's the python-style path -- the same one you would use when running <code>uvicorn</code> through command-line. Imagine that you are importing the module and then appending <code>\":\" + version_bundle_variable_name</code> at the end.</p> <pre><code>cadwyn codegen path.to.version.bundle:version_bundle_variable\n</code></pre> <p>Note that:</p> <ul> <li>You don't use the system path style for both arguments. Instead, imagine that you are importing these modules in python -- that's the way you want to write down the paths.</li> <li>Take a look at how we point to our version bundle. We use \":\" to say that it's a variable within the specified module</li> </ul>"},{"location":"concepts/code_generation/#function-interface","title":"Function interface","text":"<p>You can use <code>cadwyn.generate_code_for_versioned_packages</code> which accepts a <code>template_module</code> (a directory which contains the latest versions) and <code>versions</code> which is the <code>VersionBundle</code> from which to generate versions.</p>"},{"location":"concepts/endpoint_migrations/","title":"Endpoint migrations","text":"<p>Note that the endpoint constructor contains a second argument that describes the methods of the endpoints you would like to edit. If you have two routes for a single endpoint and you put both of their methods into the instruction -- both of them are going to be changed as you would expect.</p>"},{"location":"concepts/endpoint_migrations/#defining-endpoints-that-didnt-exist-in-new-versions","title":"Defining endpoints that didn't exist in new versions","text":"<p>If you had an endpoint in old version but do not have it in a new one, you must still define it but mark it as deleted.</p> <pre><code>@router.only_exists_in_older_versions\n@router.get(\"/users/{user_id}\")\nasync def my_old_endpoint():\n    ...\n</code></pre> <p>and then define it as existing in one of the older versions:</p> <pre><code>from cadwyn.structure import VersionChange, endpoint\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        endpoint(\"/users/{user_id}\", [\"GET\"]).existed,\n    )\n</code></pre>"},{"location":"concepts/endpoint_migrations/#defining-endpoints-that-didnt-exist-in-old-versions","title":"Defining endpoints that didn't exist in old versions","text":"<p>If you have an endpoint in your new version that must not exist in older versions, you define it as usual and then mark it as \"non-existing\" in old versions:</p> <pre><code>from cadwyn.structure import VersionChange, endpoint\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        endpoint(\"/companies/{company_id}\", [\"GET\"]).didnt_exist,\n    )\n</code></pre>"},{"location":"concepts/endpoint_migrations/#changing-endpoint-attributes","title":"Changing endpoint attributes","text":"<p>If you want to change any attribute of your endpoint in a new version, you can return the attribute's value in all older versions like so:</p> <pre><code>from cadwyn.structure import VersionChange, endpoint\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        endpoint(\"/users/{user_id}\", [\"GET\"]).had(\n            description=\"My old description\"\n        ),\n    )\n</code></pre>"},{"location":"concepts/endpoint_migrations/#dependency-alteration-warning","title":"Dependency alteration warning","text":"<p>Note that changing endpoint <code>dependencies</code> is only going to affect the initial validation. So Cadwyn will take your altered dependencies and run them on each request to the endpoint but ultimately your endpoint code is always going to use the HEAD version of your dependencies. So be careful.</p> <p>Note also that if some of your dependencies were added at app/router level -- they are going to be overwritten by this instruction. Most of the time it is rather safe, however, as all the necessary dependencies will still run on HEAD version.</p>"},{"location":"concepts/endpoint_migrations/#dealing-with-endpoint-duplicates","title":"Dealing with endpoint duplicates","text":"<p>Sometimes, when you're doing some advanced changes in between versions, you will need to rewrite your endpoint function entirely. So essentially you'd have the following structure:</p> <pre><code>from fastapi.params import Param\nfrom fastapi.headers import Header\nfrom typing import Annotated\nfrom cadwyn import VersionedAPIRouter\n\nrouter = VersionedAPIRouter()\n\n\n@router.only_exists_in_older_versions\n@router.get(\"/users\")\ndef get_users_by_name_before_we_started_using_params(\n    user_name: Annotated[str, Header()]\n):\n    \"\"\"Do some logic with user_name\"\"\"\n\n\n@router.get(\"/users\")\ndef get_users_by_name(user_name: Annotated[str, Param()]):\n    \"\"\"Do some logic with user_name\"\"\"\n</code></pre> <p>As you see, these two functions have the same methods and paths. And when you have many versions, you can have even more functions like these two. So how do we ask cadwyn to restore only one of them and delete the other one?</p> <pre><code>from cadwyn.structure import VersionChange, endpoint\n\n\nclass UseParamsInsteadOfHeadersForUserNameFiltering(VersionChange):\n    description = (\n        \"Use params instead of headers for user name filtering in GET /users \"\n        \"because using headers is a bad API practice in such scenarios.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        # We need to specify the name, otherwise, we will encounter an exception due to having two identical endpoints\n        # with the same path and method\n        endpoint(\n            \"/users\",\n            [\"GET\"],\n            func_name=\"get_users_by_name_before_we_started_using_params\",\n        ).existed,\n        # We also need to specify the name here because, following the instruction above,\n        # we now have two existing endpoints\n        endpoint(\"/users\", [\"GET\"], func_name=\"get_users_by_name\").didnt_exist,\n    )\n</code></pre> <p>So by using a more concrete <code>func_name</code>, we are capable to distinguish between different functions that affect the same routes.</p>"},{"location":"concepts/enum_migrations/","title":"Enum migrations","text":"<p>All of the following instructions affect only code generation.</p>"},{"location":"concepts/enum_migrations/#adding-enum-members","title":"Adding enum members","text":"<p>Note that adding enum members can be a breaking change unlike adding optional fields to a schema. For example, if I return a list of entities, each of which has some type, and I add a new type -- then my client's code is likely to break.</p> <p>So I suggest adding enum members in new versions as well.</p> <pre><code>from cadwyn.structure import VersionChange, enum\nfrom enum import auto\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        enum(my_enum).had(foo=\"baz\", bar=auto()),\n    )\n</code></pre>"},{"location":"concepts/enum_migrations/#removing-enum-members","title":"Removing enum members","text":"<pre><code>from cadwyn.structure import VersionChange, enum\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        enum(my_enum).didnt_have(\"foo\", \"bar\"),\n    )\n</code></pre>"},{"location":"concepts/main_app/","title":"Main App","text":"<p>Cadwyn's standard usage is done with a single customized FastAPI app: <code>cadwyn.Cadwyn</code>. It accepts all the same arguments as <code>FastAPI</code> three more keyword-only arguments:</p> <ul> <li>Required <code>versions: VersionBundle</code> describes all versions within your application</li> <li>Optional <code>api_version_header_name: str = \"x-api-version\"</code> is the header that Cadwyn will use for routing to different API versions of your app</li> </ul> <p>After you have defined a main app, you can add versioned API routers to it using <code>Cadwyn.generate_and_include_versioned_routers(*routers)</code></p> <pre><code>from cadwyn import VersionedAPIRouter, Cadwyn\nfrom versions import my_version_bundle\n\n\nrouter = VersionedAPIRouter(prefix=\"/users\")\n\n\n@router.get(\"/users/\", tags=[\"users\"])\nasync def read_users():\n    return [{\"username\": \"Rick\"}, {\"username\": \"Morty\"}]\n\n\n@router.get(\"/users/{username}\", tags=[\"users\"])\nasync def read_user(username: str):\n    return {\"username\": username}\n\n\napp = Cadwyn(versions=my_version_bundle)\napp.generate_and_include_versioned_routers(router)\n</code></pre> <p>That's it! <code>generate_and_include_versioned_routers</code> will generate all versions of your routers based on the <code>versions</code> argument and will use schemas from the versioned schema directories parallel to <code>versions.latest_schema_package</code>.</p>"},{"location":"concepts/main_app/#routing","title":"Routing","text":"<p>Cadwyn is built on header-based routing. First, we route requests to the appropriate API version based on the version header (<code>x-api-version</code> by default). Then we route by the appropriate url path and method. Currerntly, Cadwyn only works with ISO date-based versions (such as <code>2022-11-16</code>). If the user sends an incorrect API version, Cadwyn picks up the closest lower applicable version. For example, <code>2022-11-16</code> in request can be matched by <code>2022-11-15</code> and <code>2000-01-01</code> but cannot be matched by <code>2022-11-17</code>.</p> <p>However, header-based routing is only the standard way to use Cadwyn. If you want to use any other sort of routing, you can use Cadwyn directly through <code>cadwyn.generate_versioned_routers</code>. Just remember to update the <code>VersionBundle.api_version_var</code> variable each time you route some request to a version. This variable allows Cadwyn to do side effects and data migrations.</p>"},{"location":"concepts/main_app/#versionedapirouter","title":"VersionedAPIRouter","text":"<p>Cadwyn has its own API Router class: <code>cadwyn.VersionedAPIRouter</code>. You are free to use a regular <code>fastapi.APIRouter</code> but <code>cadwyn.VersionedAPIRouter</code> has a special decorator <code>only_exists_in_older_versions(route)</code> which allows you to define routes that have been previously deleted. First you define the route and than add this decorator to it.</p>"},{"location":"concepts/methodology/","title":"Methodology","text":"<p>Cadwyn implements a methodology that is based on the following set of principles:</p> <ul> <li>Each version is made up of \"version changes\" or \"compatibility gates\" which describe independent atomic differences between it and previous version</li> <li>We make a new version if an only if we have breaking changes</li> <li>Versions must have little to no effect on the business logic</li> <li>Versions must always be compatible in terms of data</li> <li>Creating new versions is avoided at all costs</li> <li>Any backwards compatible features must be backported to all compatible versions</li> </ul> <p>These rules give us an ability to have a large number of self-documenting versions while encapsulating their complexity in small version change classes, providing a consistent and stable experience to our users.</p> <p>So if we see that we need to make a breaking change, our general approach is to:</p> <ol> <li>Make the breaking change in your schemas, routes, or business logic</li> <li>Write a version change class (and sometimes a little extra) that describes the difference between the new version and the old version</li> </ol>"},{"location":"concepts/module_migrations/","title":"Module migrations","text":"<p>Oftentimes you start depending on new types in-between versions. For example, let's say that you depended on <code>Invoice</code> schema within your <code>data.head.users</code> in older versions but now you do not. This means that once we run code generation and this type gets back into some annotation of some schema in <code>data.head.users</code> -- it will not be imported because it was not imported in <code>latest</code>. To solve problems like this one, we have <code>module</code> instructions:</p> <pre><code>from cadwyn.structure import VersionChange, module\nimport data.head.users\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        module(data.head.users).had(import_=\"from .invoices import Invoice\"),\n    )\n</code></pre> <p>Which will add-in this import at the top of <code>users</code> file in all versions before this version change.</p>"},{"location":"concepts/schema_migrations/","title":"Schema migrations","text":"<p>All of the following instructions affect only code generation.</p>"},{"location":"concepts/schema_migrations/#add-a-field-to-the-older-version","title":"Add a field to the older version","text":"<pre><code>from pydantic import Field\nfrom cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema)\n        .field(\"foo\")\n        .existed_as(type=list[str], info=Field(description=\"Foo\")),\n    )\n</code></pre> <p>You can also specify any string in place of type:</p> <pre><code>schema(MySchema).field(\"foo\").existed_as(type=\"AnythingHere\")\n</code></pre> <p>It is often the case that you want to add a type that has not been imported in your schemas yet. You can use module import adding to solve this issue.</p>"},{"location":"concepts/schema_migrations/#remove-a-field-from-the-older-version","title":"Remove a field from the older version","text":"<pre><code>from cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).field(\"foo\").didnt_exist,\n    )\n</code></pre>"},{"location":"concepts/schema_migrations/#change-a-field-in-the-older-version","title":"Change a field in the older version","text":"<p>If you would like to set a description or any other attribute of a field, you would do:</p> <pre><code>from cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).field(\"foo\").had(description=\"Foo\"),\n    )\n</code></pre> <p>and if you would like to unset any attribute of a field as if it was never passed, you would do:</p> <pre><code>from cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).field(\"foo\").didnt_have(\"description\"),\n    )\n</code></pre> <p>DEFAULTS WARNING:</p> <p>If you add <code>default</code> or <code>default_factory</code> into the old version of a schema -- it will not manifest in code automatically. Instead, you should add both the <code>default</code> or <code>default_factory</code>, and then also add the default value using a request migration.</p> <p>This happens because of how Cadwyn works with pydantic and sadly cannot be changed:</p> <p>Cadwyn:</p> <ol> <li>Receives the request of some version <code>V</code></li> <li>Validates the request using the schemas from <code>V</code></li> <li>Marshalls the unmarshalled request body into a raw data structure using <code>BaseModel.dict</code> (<code>BaseModel.model_dump</code> in Pydantic v2) using exclude_unset=True</li> <li>Passes the request through all request migrations from <code>V</code> to <code>latest</code></li> <li>Validates the request using <code>latest</code> schemas</li> </ol> <p>The part that causes the aforementioned problem is our usage of <code>exclude_unset=True</code>. Sadly, when we use it, all default fields do not get set so <code>latest</code> does not receive them. And if <code>latest</code> does not have the same defaults (for example, if the field has no default and is required in <code>latest</code>), then an error will occur. If we used <code>exclude_unset=False</code>, then <code>exclude_unset</code> would lose all its purpose for the users of our library so we cannot abandon it. Instead, you should set all extra on step 4 in your request migrations.</p>"},{"location":"concepts/schema_migrations/#add-a-validator-to-the-older-version","title":"Add a validator to the older version","text":"<pre><code>from pydantic import Field, validator\nfrom cadwyn.structure import VersionChange, schema\n\n\n@validator(\"foo\")\ndef validate_foo(cls, value):\n    if not \":\" in value:\n        raise TypeError\n    return value\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).validator(validate_foo).existed,\n    )\n</code></pre>"},{"location":"concepts/schema_migrations/#remove-a-validator-from-the-older-version","title":"Remove a validator from the older version","text":"<pre><code>from pydantic import Field, validator\nfrom cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).validator(MySchema.validate_foo).didnt_exist,\n    )\n</code></pre>"},{"location":"concepts/schema_migrations/#rename-a-schema-in-the-older-version","title":"Rename a schema in the older version","text":"<p>If you wish to rename your schema to make sure that its name is different in openapi.json:</p> <pre><code>from cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).had(name=\"OtherSchema\"),\n    )\n</code></pre> <p>which will replace all references to this schema with the new name.</p>"},{"location":"concepts/service_structure/","title":"Service structure","text":"<p>The service structure with Cadwyn is fairly straighforward. See the example service or follow the steps above:</p> <ol> <li>Define a VersionBundle where you add your first version and <code>data/head</code> package.</li> <li>Create a <code>data/latest</code> directory and add your latest version of schemas there. This will serve as a template directory for future code generation.</li> <li>Run code generation that will create generated versions of your <code>latest</code> directory next to it.</li> <li>Create a Cadwyn app that you will use instead of <code>FastAPI</code>. Pass your <code>VersonBundle</code> to it.</li> <li>Create a VersionedAPIRouter that you will use for defining your versioned routes.</li> <li>Include this router and any other versioned routers into your <code>Cadwyn</code> app. It will duplicate your router in runtime for each API version.</li> </ol> <p>The recommended directory structure for cadwyn is as follows:</p> <pre><code>\u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 unversioned\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 users.py\n\u2502   \u2514\u2500\u2500 latest          # The latest version of your schemas goes here\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 users.py\n\u2514\u2500\u2500 versions\n    \u251c\u2500\u2500 __init__.py     # Your version bundle goes here\n    \u2514\u2500\u2500 v2001_01_01.py  # Your version changes go here\n</code></pre> <p>Schemas, enums, and any other versioned data are inside the <code>data.head</code> package, version changes are inside the <code>versions.vXXXX_XX_XX</code> modules, and version bundle is inside the <code>versions.__init__</code> module. It includes all versions with all version changes -- including the ones you add in the recipes.</p> <p>You can assume for the purpose of our guides that we already have a version 2000-01-01 and we are making a new version 2001-01-01 with the changes from our scenarios.</p> <p>You can structure your business logic, database, and all other parts of your application in any way you like.</p> <p>That's it! Your service is ready to be versioned. We can now use the most powerful feature of Cadwyn: version changes.</p>"},{"location":"concepts/testing/","title":"Testing","text":"<p>As Cadwyn allows you to keep the same business logic, database schemas, etc -- you should have a single set of common tests that test your current latest version. These tests are going to work like the regular tests that you would have if you did not have any API versioning.</p> <p>Here's the recommended file structure for tests:</p> <pre><code>\u251c\u2500\u2500 tests\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 conftest.py\n\u2502   \u251c\u2500\u2500 head\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 conftest.py\n\u2502   \u2502   \u251c\u2500\u2500 test_users.py\n\u2502   \u2502   \u251c\u2500\u2500 test_admins.py\n\u2502   \u2502   \u2514\u2500\u2500 test_invoices.py\n\u2502   \u251c\u2500\u2500 v2022_11_16\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 conftest.py\n\u2502   \u2502   \u2514\u2500\u2500 test_invoices.py\n\u2502   \u2514\u2500\u2500 v2023_03_11\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 conftest.py\n\u2502       \u2514\u2500\u2500 test_users.py\n</code></pre> <p>Each time you create a new version, I advise you to follow the following process:</p> <ol> <li>Duplicate the subset of the HEAD tests and fixtures that is going to be affected by the new version and add it into its own directory, same as the version name. Run all the tests to validate that they pass.</li> <li>Make the breaking changes you wished to make and write the migrations</li> <li>Change HEAD tests to accomodate the new behavior (note how this should be done in step (1) if you prefer to follow TDD)</li> </ol> <p>This approach will make it easy to keep the old versions covered by tests and will keep the duplication in tests minimal.</p>"},{"location":"concepts/version_changes/","title":"Version Changes","text":"<p>Version changes are the backbone of Cadwyn. They give you an ability to describe things like \"This field in that schema had a different name in an older version\" or \"this endpoint did not exist in all earlier versions\".</p> <p>In Cadwyn, your business logic always only works with a single version -- HEAD, which is essentially your representation of your latest version. This approach decouples your business logic from versioning and allows you to have hundreds of API versions using the same database models and business logic while also staying sane at the same time.</p> <p>Whenever add a new version, you go through the following steps:</p> <ol> <li>Make a breaking change in your HEAD version</li> <li>Reverse it for all your older versions using special \"migration instructions\" so that your current users are not affected by the breaking changes</li> </ol> <p>These migration instructions for reverting the breaking changes are gathered into groups to make them easier to maintain. Let's say that you want to rename the field \"creation_date\" into \"created_at\" but you also want to delete the endpoint \"GET /v1/tax_ids\": these changes are unrelated so they should be put into different groups. On the other hand, deletion of \"POST /v1/tax_ids\" endpoint should go into the same group as the deleetion of \"GET /v1/tax_ids\". These groups are very important to make the changes easily understandable for both your users and your developers.</p> <p>Each such group is called a version change:</p> <pre><code># versions/v2023_02_10.py\n\nfrom cadwyn.structure import VersionChange, endpoint\n\n\nclass RemoveTaxIDEndpoints(VersionChange):\n    description = \"Remove `GET /v1/tax_ids` and `POST /v1/tax_ids` endpoints\"\n    instructions_to_migrate_to_previous_version = (\n        endpoint(\"/v1/tax_ids\", [\"GET\", \"POST\"]).existed,\n    )\n</code></pre> <p>After you have described them, you add your version change class(es) into your version bundle to activate them:</p> <pre><code># versions/__init__.py\n\nfrom cadwyn.structure import VersionBundle, Version\nfrom datetime import date\nfrom data import latest\n\nfrom .v2023_02_10 import RemoveTaxIDEndpoints\n\n\nversions = VersionBundle(\n    HeadVersion(),\n    Version(date(2023, 2, 10), RemoveTaxIDEndpoints),\n    Version(date(2022, 11, 16)),\n    head_schemas_package=latest,\n)\n</code></pre> <p>This instructs Cadwyn to undelete these endpoints in all versions older than 2023-02-10.</p> <p>Now let's discuss what each of these parts does and why:</p>"},{"location":"concepts/version_changes/#versionbundle","title":"VersionBundle","text":"<p><code>VersionBundle</code> is your single source of truth for your list of versions. It contains your list of versions and all version changes associated with them. Each version change is a single group of breaking changes. Each <code>Version</code> contains a group of version changes that caused this version to be created. So for example, if I deleted an endpoint <code>POST /v1/tax_ids</code> in version <code>2023-02-10</code>, then I'll add the version change for deleting that endpoint into <code>2023-02-10</code>. For example:</p> <pre><code># versions/__init__.py\n\nfrom cadwyn.structure import VersionBundle, Version\nfrom datetime import date\nfrom data import latest\n\nfrom .v2023_02_10 import RemoveTaxIDEndpoints\n\n\nversions = VersionBundle(\n    HeadVersion(),\n    Version(date(2023, 2, 10), RemoveTaxIDEndpoints),\n    Version(date(2022, 11, 16)),\n    head_schemas_package=latest,\n)\n</code></pre> <p>See how our first version, <code>2022-11-16</code> does not have any version changes? That is intentional! How can it have breaking changes if there are no versions before it?</p>"},{"location":"concepts/version_changes/#version","title":"Version","text":"<p><code>Version</code> is simply an ordered collection of version changes that allows you to describe when each version change happened so that Cadwyn is able to generate your schemas and routes for all versions correctly --  based on which version changes are located in which versions.</p>"},{"location":"concepts/version_changes/#headversion","title":"HeadVersion","text":"<p>Cadwyn has a special HEAD version: it is the only version you will write by hand and use directly in your business logic. It is also the version that is used by Cadwyn for generating all other versions.</p> <p>When handling an HTTP request, Cadwyn will first validate it with the appropriate API version, then Cadwyn will apply all converters from the request's API version and until the latest API version to it, and then finally Cadwyn will convert the request to the appropriate schema from HEAD (the schema that was used for generating the versioned schema from request's API version).</p> <p>So Cadwyn will migrate all requests from all versions to HEAD version to make sure that your business logic knows about only one version.</p> <p>HEAD is very similar to your latest version with a few key differences:</p> <ul> <li>Latest is user-facing while HEAD is only used internally by you and Cadwyn</li> <li>Latest is generated while HEAD is maintained by you by hand</li> <li>Latest only includes the fields that our user is supposed to see in the latest version while HEAD can include some fields missing from latest. For example, if an earlier version contained a field completely incompatible with latest -- HEAD will have it too to make sure that old versions can function same as before. This also applies to field types: if a field became required in latest but was nullable in an earlier version, then HEAD will have it as nullable to make sure that any earlier version request can easily be converted into a HEAD request</li> <li>Latest can include constraints that are incompatible with older versions while HEAD can contain no constraints at all if you want -- the user-facing schemas are used for validation before the request is converted to HEAD so HEAD does not need to re-validate anything if you do not want it to</li> </ul>"},{"location":"concepts/version_changes/#versionchange","title":"VersionChange","text":"<p><code>VersionChange</code> classes describe each atomic group of business capabilities that you have altered in a version.</p>"},{"location":"concepts/version_changes/#versionchange__name__","title":"VersionChange.__name__","text":"<p>The name of the version change, <code>RemoveTaxIDEndpoints</code>, describes what breaking change has happened. It must be a verb and it is the best resource for your new developers to quickly understand what happened between the versions. Do not be shy to use really long names -- it is better to have a long name than to create a misunderstanding. Avoid generic names such as <code>RefactorUserFields</code>. Better have an ugly name such as <code>RenameCreationDatetimeAndUpdateDatetimeToCreatedAtAndUpdatedAt</code> then to have a generic name such as <code>RefactorFields</code>. Because after just a few of such version changes, your versioning structure can become completely unreadable:</p> <pre><code>versions = VersionBundle(\n    Version(date(2023, 5, 9), ChangeCreateLogic, AddRequiredFields),\n    Version(date(2023, 4, 2), DeleteEndpoint, ChangeFields, RenameFields),\n    Version(date(2023, 2, 10), RenameEndpoints, RefactorFields),\n    Version(date(2022, 11, 16)),\n    head_schemas_package=latest,\n)\n</code></pre>"},{"location":"concepts/version_changes/#versionchangedescription","title":"VersionChange.description","text":"<p>The description field of your version change must be even more detailed. In fact, it is intended to be the name and the summary of the version change for your clients. It must clearly state to you clients what happened and why. So you need to make it grammatically correct, detailed, concrete, and written for humans. Note that you do not have to use a strict machine-readable format -- it is a portion of documentation, not a set of intructions. Let's take Stripe's description to one of their version changes as an example:</p> <pre><code>Event objects (and webhooks) will now render `request` subobject that contains a request ID and idempotency key instead of just a string request ID.\n</code></pre> <p>It is concise, descriptive, and human-readable -- just like any good documentation. Now let's look at the bad description:</p> <pre><code>Migration from first version (2022-11-16) to 2023-09-01 version.\nChanges:\n* Changed schema for 'POST /v1/tax_ids' endpoint\n</code></pre> <ul> <li>Its first line, <code>Migration from first version (2022-11-16) to 2023-09-01 version.</code>, duplicates the already-known information -- your developers will know which version <code>VersionChange</code> migrates to and from by its location in VersionBundle and most likely by its file name. Your clients will also know that because you can automatically infer this information from  So it is simply standing in the way of actually useful parts of the documentation</li> <li>Its second line, <code>Changes:</code>, does not make any sense as well because description of a <code>VersionChange</code> cannot describe anything but changes. So again, it's stating the obvious and making it harder for our readers to understand the crux of the change</li> <li>Its third line, <code>Changed schema for 'POST /v1/tax_ids' endpoint</code>, gives both too much and too little information. First of all, it talks about changing schema but it never mentions what exactly changed. Remember: we are doing this to make it easy for our clients to migrate from one version to another. Insteaad, it is much better to mention the openapi model name that you changed, the fields you changed, and why you changed them</li> </ul>"},{"location":"concepts/version_changes/#versionchangeinstructions_to_migrate_to_previous_version","title":"VersionChange.instructions_to_migrate_to_previous_version","text":"<p>In Cadwyn, you use the latest version. This attribute is a way for you to describe how your schemas and endpoints looked in previous versions so that Cadwyn can guess code generation and route generation to recreate the old schemas and endpoints for your clients. So you only need to maintain your latest schemas and your migrations while Cadwyn takes care of the rest. In fact, you spend barely any effort on maintaining your migrations because they are effectively immutable -- they describe the breaking changes that happened in the past so there is no need to ever change them.</p> <p>This approach of maintaining the present and describing the past might appear weird. You just need to form the correct mindset which is counter-intuitive at first but after just one or two attempts at versioning you will see how much sense this approach makes.</p>"},{"location":"concepts/version_changes/#data-migrations","title":"Data migrations","text":"<p>Let's say that we renamed the field <code>creation_date</code> into <code>created_at</code>. We have altered our schemas -- that's great! But when our clients send us requests using the old versions of our API -- we will still get the data where we have <code>creation_date</code> instead of <code>created_at</code>. How do we solve this? Well, in Cadwyn your business logic never receives requests of the old versions. Instead, it receives only the requests of the latest version. So when you define a version change that renames a field, you need to also define how to convert the request body from the old version to the newer version. For example:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    convert_request_to_next_version_for,\n)\nfrom data.head.invoices import InvoiceCreateRequest\n\n\nclass RemoveTaxIDEndpoints(VersionChange):\n    description = \"Rename `Invoice.creation_date` into `Invoice.created_at`.\"\n    instructions_to_migrate_to_previous_version = (\n        schema(InvoiceCreateRequest)\n        .field(\"creation_date\")\n        .had(name=\"created_at\"),\n    )\n\n    @convert_request_to_next_version_for(InvoiceCreateRequest)\n    def rename_creation_date_into_created_at(request: RequestInfo):\n        request.body[\"created_at\"] = request.body.pop(\"creation_date\")\n</code></pre> <p>Notice how we specified the schema for <code>InvoiceCreateRequest</code> in our migration? This will signal to Cadwyn to apply it to all routes that have this schema as their body.</p> <p>Now we have not only described how schemas changed but we have also described how to migrate a request of the old version to the new version. When Cadwyn receives a request of a particular version, the request is first validated against the schema of that particular version. Then Cadwyn applies all request migrations until the latest version to migrate the request to latest. So now your business logic receives the latest version of the request yet for your clients you have two versions of your API -- you have added variability without introducing any complexity into your business logic.</p> <p>But wait.. What happens with the <code>Invoice</code> responses? Your business logic will now return <code>created_at</code> so your clients from old versions will be affected! Cadwyn has a tool for that too: we migrate our responses as well. Requests were migrated forward in versions but responses are migrated backward in versions! So your business logic returns a response of the latest version and Cadwyn will use your response migrations to migrate it back the version of your client's request:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n)\nfrom data.head.invoices import (\n    BaseInvoice,\n    InvoiceCreateRequest,\n    InvoiceResource,\n)\n\n\nclass RemoveTaxIDEndpoints(VersionChange):\n    description = \"Rename `Invoice.creation_date` into `Invoice.created_at`.\"\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseInvoice).field(\"creation_date\").had(name=\"created_at\"),\n    )\n\n    @convert_request_to_next_version_for(InvoiceCreateRequest)\n    def rename_creation_date_into_created_at(request: RequestInfo):\n        request.body[\"created_at\"] = request.body.pop(\"creation_date\")\n\n    @convert_response_to_previous_version_for(InvoiceResource)\n    def rename_created_at_into_creation_date(response: ResponseInfo):\n        response.body[\"creation_date\"] = response.body.pop(\"created_at\")\n</code></pre> <p>Notice how we specified the schema for <code>InvoiceResource</code> in our migration? This will signal to Cadwyn to apply it to all routes that have this schema as their <code>response_model</code>. Notice also that we now use <code>BaseInvoice</code> in our instructions -- let's imagine that it is the parent of both <code>InvoiceCreateRequest</code> and <code>InvoiceResource</code> so renaming it there will rename it in these schemas as well. You can, however, apply the instructions to both individual schemas instead of their parent if you want to.</p> <p>Now our request comes, Cadwyn migrates it to the latest version using our request migration, then we do our business logic, return the latest response from it, and Cadwyn migrates it back to the request version. Does our business logic or database know about the fact that we have two versions? No, not at all! It is zero-cost. Imagine how beneficial it is when you support not two but two hundred versions.</p> <p></p> <p>Notice how we used the latest versions of our schemas in our migration -- this pattern can be found everywhere in Cadwyn. You use the latest version of your schemas to describe what happened to all other versions because other versions might not exist when you are defining migrations for them.</p>"},{"location":"concepts/version_changes/#path-based-migration-specification","title":"Path-based migration specification","text":"<p>Oftentimes you will need to migrate not based on the request body or response model but based on the path of the endpoint. This happens when, for example, endpoint does not have a request body or its response model is used in other places that we do not want to migrate. Let's pick the example above and use paths instead of schemas:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n)\nfrom data.head.invoices import BaseInvoice\n\n\nclass RemoveTaxIDEndpoints(VersionChange):\n    description = \"Rename `Invoice.creation_date` into `Invoice.created_at`.\"\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseInvoice).field(\"creation_date\").had(name=\"created_at\"),\n    )\n\n    @convert_request_to_next_version_for(\"/v1/invoices\", [\"POST\"])\n    def rename_creation_date_into_created_at(request: RequestInfo):\n        request.body[\"created_at\"] = request.body.pop(\"creation_date\")\n\n    @convert_response_to_previous_version_for(\"/v1/invoices\", [\"GET\"])\n    def rename_created_at_into_creation_date(response: ResponseInfo):\n        response.body[\"creation_date\"] = response.body.pop(\"created_at\")\n</code></pre> <p>Though I highly recommend you to stick to schemas as it is much easier to introduce inconsistencies when using paths; for example, when you have 10 endpoints with the same response body schema but you forgot to add migrations for 3 of them because you use paths instead of schemas.</p>"},{"location":"concepts/version_changes/#migration-of-http-errors","title":"Migration of HTTP errors","text":"<p>Oftentimes you need to raise <code>fastapi.HTTPException</code> in your code to signal some errors to your users. However, if you want to change the status code of some error, it would be a breaking change because your error status codes and sometimes even their bodies are a part of your API contract.</p> <p>By default, Cadwyn's response migrations do not handle errors but you can use the <code>migrate_http_errors</code> keyword argument to enable it:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    convert_response_to_previous_version_for,\n)\nfrom data.head.invoices import BaseInvoice\n\n\nclass RemoveTaxIDEndpoints(VersionChange):\n    description = \"Change status code in 'GET /v1/invoices' when invoice was not found from 400 to 404\"\n    instructions_to_migrate_to_previous_version = ()\n\n    @convert_response_to_previous_version_for(\n        \"/v1/invoices\", [\"GET\"], migrate_http_errors=True\n    )\n    def change_400_to_404(response: ResponseInfo):\n        if response.status_code == 400:\n            response.status_code = 404\n</code></pre>"},{"location":"concepts/version_changes/#migration-of-non-body-attributes","title":"Migration of non-body attributes","text":"<p>Cadwyn has an ability to migrate more than just request bodies.</p> <p><code>RequestInfo</code> has the the following interfaces to migrate requests:</p> <ul> <li><code>body: Any</code></li> <li><code>headers: starlette.datastructures.MutableHeaders</code></li> <li><code>cookies: dict[str, str]</code></li> <li><code>query_params: dict[str, str]</code></li> </ul> <p><code>ResponseInfo</code> has the the following interfaces to migrate responses:</p> <ul> <li><code>body: Any</code></li> <li><code>status_code: int</code></li> <li><code>headers: starlette.datastructures.MutableHeaders</code></li> <li>set_cookie</li> <li>delete_cookie</li> </ul>"},{"location":"concepts/version_changes/#internal-representations","title":"Internal representations","text":"<p>We have only reviewed simplistic cases so far. But what happens when you cannot just migrate your data that easily? It can happen because your earlier versions had more data than your newer versions. Or that data had more formats.</p> <p>Let's imagine that previously the <code>User</code> schema had a list of addresses but now we want to make a breaking change and turn them into a single address. The naive migration will just take the first address from the list for requests and turn that one address into a list for responses like so:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n)\nfrom data.head.users import BaseUser, UserCreateRequest, UserResource\n\n# THIS IS AN EXAMPLE OF A BAD MIGRATION\nclass RemoveTaxIDEndpoints(VersionChange):\n    description = \"Users now have `address` field instead of `addresses`\"\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser).field(\"address\").didnt_exist,\n        schema(BaseUser).field(\"addresses\").existed_as(type=list[str]),\n    )\n\n    @convert_request_to_next_version_for(BaseUser)\n    def turn_addresses_into_a_single_item(request: RequestInfo):\n        addresses = request.body.pop(\"addresses\")\n        # The list could have been empty in the past so new \"address\"\n        # field must be nullable.\n        request.body[\"address\"] = addresses[0] if addresses else None\n\n    @convert_response_to_previous_version_for(BaseUser)\n    def turn_address_into_a_list(response: ResponseInfo):\n        response.body[\"addresses\"] = [response.body.pop(\"address\")]\n</code></pre> <p>But this will not work. Now when the user from the old version asks us to save three addresses, we will in fact save only one. Old data is also going to be affected -- if old users had multiple addresses, we will only be able to return one of them. This is bad -- we have made a breaking change!</p> <p>In order to solve this problem, Cadwyn uses a concept of internal representations. An internal representation of your data is like a database entry of your data -- it is its latest version plus all the fields that are incompatible with the latest API version. If we were talking about classes, then internal representation would be a child of your latest schemas -- it has all the same data and a little more, it expands its functionality. Essentially your internal representation of user object can contain much more data than your latest schemas.</p> <p>So all your requests get migrated to HEAD, which is the internal representation of latest -- but not exactly the latest itself. So its data is really similar to latest. Same happens with your responses -- you do not respond with and migrate from the latest version of your data, you respond with its internal representation which is really close to the actual latest schemas.</p> <p>In responses, returning the internal representation is simple: just return your database model or a dict with everything you need for all your versions. In the user address example, we would continue storing the list of addresses in our database but then add the single address to our response. Latest schemas will simply strip it but our older schemas will be able to use it!</p> <pre><code># in your business logic\n\nreturn {\"address\": user.addresses[0] if user.addresses else None, **user}\n</code></pre> <p>So now your migration will look like the following:</p> <pre><code>from cadwyn.structure import VersionChange, schema\nfrom data.head.users import User\n\n\nclass RemoveTaxIDEndpoints(VersionChange):\n    description = \"Users now have `address` field instead of `addresses`\"\n    instructions_to_migrate_to_previous_version = (\n        schema(User).field(\"address\").didnt_exist,\n        schema(User).field(\"addresses\").existed_as(type=list[str]),\n    )\n</code></pre> <p>Yes, we do not need any of the migrations anymore because responses are handled automatically. See how-to section for an example of how we would achieve the same feat for requests.</p>"},{"location":"concepts/version_changes/#manual-body-migrations","title":"Manual body migrations","text":"<p>Oftentimes you will have a need to migrate your data outside of routing, manually. For example, when you need to send a versioned response to your client via webhook or inside a worker/cronjob. In these instances, you can use <code>cadwyn.VersionBundle.migrate_response_body</code>:</p> <pre><code>from data.head.users import UserResource\nfrom versions import version_bundle\n\nbody_from_2000_01_01 = version_bundle.migrate_response_body(\n    UserResource, latest_body={\"name\": \"John\"}, version=date(2000, 1, 1)\n)\n</code></pre> <p>The returned <code>body_from_2000_01_01</code> is your data passed through all converters (similar to how it would when a response is returned from your route) and wrapped into <code>data.v2000_01_01.UserResource</code>. The fact that it is wrapped gives us the ability to include pydantic's defaults.</p>"},{"location":"concepts/version_changes/#streamingresponse-and-fileresponse-migrations","title":"StreamingResponse and FileResponse migrations","text":"<p>Migrations for the bodies of <code>fastapi.responses.StreamingResponse</code> and <code>fastapi.responses.FileResponse</code> are not directly supported yet (1, 2). However, you can use <code>ResponseInfo._response</code> attribute to get access to the original <code>StreamingResponse</code> or <code>FileResponse</code> and modify it in any way you wish within your migrations.</p>"},{"location":"concepts/version_changes/#pydantic-2-rootmodel-migration-warning","title":"Pydantic 2 RootModel migration warning","text":"<p>Pydantic 2 has an interesting implementation detail: <code>pydantic.RootModel</code> instances are memoized. So the following code is going to output <code>True</code>:</p> <pre><code>from data.head.users import User\nfrom pydantic import RootModel\n\nBulkCreateUsersRequestBody = RootModel[list[User]]\nBulkCreateUsersResponseBody = RootModel[list[User]]\n\nprint(BulkCreateUsersRequestBody is BulkCreateUsersResponseBody)  # True\n</code></pre> <p>So if you make a migration that should only affect one of these schemas -- it will automatically affect both. A recommended alternative is to either use subclassing:</p> <pre><code>from data.head.users import User\nfrom pydantic import RootModel\n\nUserList = RootModel[list[User]]\n\n\nclass BulkCreateUsersRequestBody(UserList):\n    pass\n\n\nclass BulkCreateUsersResponseBody(UserList):\n    pass\n\n\nprint(BulkCreateUsersRequestBody is BulkCreateUsersResponseBody)  # False\n</code></pre> <p>or to specify migrations using endpoint path instead of a schema.</p>"},{"location":"concepts/version_changes/#version-changes-with-side-effects","title":"Version changes with side effects","text":"<p>Sometimes you will use API versioning to handle a breaking change in your business logic, not in the schemas themselves. In such cases, it is tempting to add a version check and just follow the new business logic such as:</p> <pre><code>if api_version_var.get() &gt;= date(2022, 11, 11):\n    # do new logic here\n    ...\n</code></pre> <p>In cadwyn, this approach is highly discouraged. It is recommended that you avoid side effects like this at any cost because each one makes your core logic harder to understand. But if you cannot, then I urge you to at least abstract away versions and versioning from your business logic which will make your code much easier to read.</p> <p>WARNING: Side effects are the wrong way to do API Versioning. In 99% of time, you will not need them. Please, think twice before using them. API Versioning is about having the same underlying app and data while just changing the schemas and api endpoints to interact with it. By introducing side effects, you leak versioning into your business logic and possibly even your data which makes your code much harder to support in the long term. If each side effect adds a single <code>if</code> to your logic, than after 100 versions with side effects, you will have 100 more <code>if</code>s. If used correctly, Cadwyn can help you support decades worth of API versions at the same time with minimal costs but side effects make it much harder to do. Changes in the underlying source, structure, or logic of your data should not affect your API or public-facing business logic.</p> <p>To simplify this, cadwyn has a special <code>VersionChangeWithSideEffects</code> class. It makes finding dangerous versions that have side effects much easier and provides a nice abstraction for checking whether we are on a version where these side effects have been applied.</p> <p>As an example, let's use the tutorial section's case with the user and their address. Let's say that we use an external service to check whether user's address is listed in it and return 400 response if it is not. Let's also say that we only added this check in the newest version.</p> <pre><code>from cadwyn.structure import VersionChangeWithSideEffects\n\n\nclass UserAddressIsCheckedInExternalService(VersionChangeWithSideEffects):\n    description = (\n        \"User's address is now checked for existense in an external service. \"\n        \"If it doesn't exist there, a 400 code is returned.\"\n    )\n</code></pre> <p>Then we will have the following check in our business logic:</p> <pre><code>from src.versions import versions, UserAddressIsCheckedInExternalService\n\n\nasync def create_user(payload):\n    if UserAddressIsCheckedInExternalService.is_applied:\n        check_user_address_exists_in_an_external_service(payload.address)\n    ...\n</code></pre> <p>So this change can be contained in any version -- your business logic doesn't know which version it has and shouldn't.</p>"},{"location":"home/CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Please follow the Keep a Changelog standard.</p>"},{"location":"home/CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"home/CHANGELOG/#3152","title":"[3.15.2]","text":""},{"location":"home/CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Openapi not being generated when lifespan was used</li> </ul>"},{"location":"home/CHANGELOG/#3151","title":"[3.15.1]","text":""},{"location":"home/CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>Badge links in the readme</li> </ul>"},{"location":"home/CHANGELOG/#3150","title":"[3.15.0]","text":""},{"location":"home/CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Optimized the calls to enrich_swagger which now happen on the startup event, once for the whole application</li> </ul>"},{"location":"home/CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>Oauth2 authentication parameters did not get passed to swagger</li> </ul>"},{"location":"home/CHANGELOG/#3140","title":"[3.14.0]","text":""},{"location":"home/CHANGELOG/#added","title":"Added","text":"<ul> <li>Current API version to per-version openapi.json</li> </ul>"},{"location":"home/CHANGELOG/#3130","title":"[3.13.0]","text":""},{"location":"home/CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Validation for path converters to make sure that impossible HTTP methods cannot be used</li> <li>Validation for both path and schema converters to make sure that they are used at some point. Otherwise, router generation will raise an error</li> </ul>"},{"location":"home/CHANGELOG/#3121","title":"[3.12.1]","text":""},{"location":"home/CHANGELOG/#fixed_3","title":"Fixed","text":"<ul> <li><code>fastapi.Response</code> subclasses with non-null bodies and 500 response causing the response to not get returned</li> <li><code>fastapi.Response</code> subclasses had invalid content length if migration affected it</li> </ul>"},{"location":"home/CHANGELOG/#3120","title":"[3.12.0]","text":""},{"location":"home/CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Rewritten header routing logic and structure to support the full feature set of FastAPI</li> </ul>"},{"location":"home/CHANGELOG/#3111","title":"[3.11.1]","text":""},{"location":"home/CHANGELOG/#fixed_4","title":"Fixed","text":"<ul> <li>Modules and enums from head versions not being detected and thus causing errors</li> </ul>"},{"location":"home/CHANGELOG/#3110","title":"[3.11.0]","text":""},{"location":"home/CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Header router is no longer reliant on the API version header -- now it simply takes the API version from the <code>VersionBundle.api_version_var</code>, thus making it easy for someone to extend header routing and set their own rules for how the default version is chosen</li> </ul>"},{"location":"home/CHANGELOG/#3101","title":"[3.10.1]","text":""},{"location":"home/CHANGELOG/#fixed_5","title":"Fixed","text":"<ul> <li>Previous version introduced a minor breaking change: if any old users depended on the pure <code>generate_versioned_routers</code> interface, their work would receive a minor yet simple breaking change.</li> </ul>"},{"location":"home/CHANGELOG/#3100","title":"[3.10.0]","text":"<p>Yanked due to a minor breaking change that we fixed in 3.10.1.</p>"},{"location":"home/CHANGELOG/#added_2","title":"Added","text":"<ul> <li>The new approach to internal schemas: instead of having them duplicate certain fields from <code>latest</code>, we introduced a new <code>HEAD</code> version -- the only one the user maintains by hand. All requests get migrated to <code>HEAD</code> and latest schemas are generated from <code>HEAD</code>. <code>cadwyn.structure.HeadVersion</code> was added to give us the ability to have migrations between <code>HEAD</code> and latest, thus eliminating the need for <code>InternalRepresentationOf</code> because all the used schemas are now the internal representations</li> </ul>"},{"location":"home/CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li><code>latest</code> is now named <code>head</code> because it no longer represents the newest version. Instead, it is the the <code>internally used</code> version and the version that is used for generating all other versions.</li> <li>the newest version is not aliased from <code>latest</code> anymore. Instead, it is generated like all the rest</li> <li>deprecated <code>InternalRepresentationOf</code> and the concept of <code>internal schemas</code> in favor of <code>HeadVersion</code> migrations</li> </ul>"},{"location":"home/CHANGELOG/#391","title":"[3.9.1]","text":""},{"location":"home/CHANGELOG/#fixed_6","title":"Fixed","text":"<ul> <li>A broken link to docs in README.md</li> </ul>"},{"location":"home/CHANGELOG/#390","title":"[3.9.0]","text":""},{"location":"home/CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Support for getting openapi.json routes using API version headers instead of path query params</li> </ul>"},{"location":"home/CHANGELOG/#380","title":"[3.8.0]","text":""},{"location":"home/CHANGELOG/#added_4","title":"Added","text":"<ul> <li>Discord status badge in README</li> <li>Logos to existing status badges in README</li> <li>An ability to specify multiple schemas when using <code>convert_request_to_next_version_for</code> and <code>convert_response_to_next_version_for</code> to be able to migrate multiple types of schemas using the same converter</li> <li>Redoc support</li> </ul>"},{"location":"home/CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Dependency from verselect. Now it is included as a part of Cadwyn</li> </ul>"},{"location":"home/CHANGELOG/#fixed_7","title":"Fixed","text":"<ul> <li><code>h11._util.LocalProtocolError</code> when raising <code>HTTPException(status_code=500)</code></li> </ul>"},{"location":"home/CHANGELOG/#371","title":"[3.7.1]","text":""},{"location":"home/CHANGELOG/#fixed_8","title":"Fixed","text":"<ul> <li>Error message for changing path params of an endpoint in an incompatible manner which listed methods instead of path params</li> </ul>"},{"location":"home/CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Deprecated <code>cadwyn generate-code-for-versioned-packages</code> and added <code>cadwyn codegen</code> instead. It doesn't require <code>template_package</code> argument anymore and does not have the <code>ignore_coverage_for_latest_aliases</code> argument as we plan to remove this feature in the future. So it only requires <code>version_bundle</code>.</li> </ul>"},{"location":"home/CHANGELOG/#370","title":"[3.7.0]","text":""},{"location":"home/CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>Deprecated <code>cadwyn generate-code-for-versioned-packages</code> and added <code>cadwyn codegen</code> instead. It doesn't require <code>template_package</code> argument anymore and does not have the <code>ignore_coverage_for_latest_aliases</code> argument as we plan to remove this feature in the future. So it only requires <code>version_bundle</code>.</li> </ul>"},{"location":"home/CHANGELOG/#366","title":"[3.6.6]","text":""},{"location":"home/CHANGELOG/#fixed_9","title":"Fixed","text":"<ul> <li>When a class-based dependency from fastapi was used (anything security related), FastAPI had hardcoded <code>isinstance</code> checks for it which it used to enrich swagger with functionality. But when the dependencies were wrapped into our function wrappers, these checks stopped passing, thus breaking this functionality in swagger. Now we ignore all dependencies that FastAPI creates. This also introduces a hard-to-solve bug: if fastapi's class-based security dependency was subclassed and then <code>__call__</code> was overriden with new dependencies that are versioned -- we will not migrate them from version to version. I hope this is an extremely rare use case though. In fact, such use case breaks Liskov Substitution Principle and doesn't make much sense because security classes already include <code>request</code> parameter which means that no extra dependencies or parameters are necessary.</li> </ul>"},{"location":"home/CHANGELOG/#365","title":"[3.6.5]","text":""},{"location":"home/CHANGELOG/#fixed_10","title":"Fixed","text":"<ul> <li>When a class-based dependency was used, its dependant was incorrectly generated, causing all affected endpoints to completely stop functioning</li> </ul>"},{"location":"home/CHANGELOG/#364","title":"[3.6.4]","text":""},{"location":"home/CHANGELOG/#363","title":"[3.6.3]","text":""},{"location":"home/CHANGELOG/#fixed_11","title":"Fixed","text":"<ul> <li>A rare pydantic 2 bug that caused <code>BaseModel</code> annotations to be corrupted when new fields were added to the schema</li> </ul>"},{"location":"home/CHANGELOG/#362","title":"[3.6.2]","text":""},{"location":"home/CHANGELOG/#fixed_12","title":"Fixed","text":"<ul> <li>Removed exception when creating <code>cadwyn.Cadwyn</code> without <code>latest_schemas_package</code> as it was a minor breaking change</li> </ul>"},{"location":"home/CHANGELOG/#360","title":"[3.6.0]","text":""},{"location":"home/CHANGELOG/#added_5","title":"Added","text":"<ul> <li>Add <code>cadwyn.VersionBundle.migrate_response_body</code> that allows us to migrate response bodies outside of routing and FastAPI</li> <li><code>latest_schemas_package</code> argument to <code>cadwyn.VersionBundle</code> to support the migration above</li> </ul>"},{"location":"home/CHANGELOG/#removed_1","title":"Removed","text":""},{"location":"home/CHANGELOG/#changed_6","title":"Changed","text":"<ul> <li>We now raise a 5xx error (<code>cadwyn.exceptions.CadwynLatestRequestValidationError</code>) whenever a request migration caused our payload to be incompatible with latest request schemas</li> <li>Deprecated <code>cadwyn.main</code> and use <code>cadwyn.applications</code> instead</li> <li>Deprecated <code>latest_schemas_package</code> argument in <code>cadwyn.Cadwyn</code></li> </ul>"},{"location":"home/CHANGELOG/#350","title":"[3.5.0]","text":""},{"location":"home/CHANGELOG/#fixed_13","title":"Fixed","text":"<ul> <li>Previously, Cadwyn did not set the default status code for ResponseInfo</li> </ul>"},{"location":"home/CHANGELOG/#added_6","title":"Added","text":"<ul> <li>HTTP status error handling in response converters using <code>convert_response_to_previous_version_for(...,  migrate_http_errors=True)</code></li> </ul>"},{"location":"home/CHANGELOG/#344","title":"[3.4.4]","text":""},{"location":"home/CHANGELOG/#fixed_14","title":"Fixed","text":"<ul> <li>Request and response converters were not applied when path params were present</li> </ul>"},{"location":"home/CHANGELOG/#343","title":"[3.4.3]","text":""},{"location":"home/CHANGELOG/#added_7","title":"Added","text":"<ul> <li><code>RouterPathParamsModifiedError</code> is now raised if <code>endpoint(...).had(path=...)</code> has different path params than the original route</li> </ul>"},{"location":"home/CHANGELOG/#342","title":"[3.4.2]","text":""},{"location":"home/CHANGELOG/#fixed_15","title":"Fixed","text":"<ul> <li>Fix import aliases in nested <code>__init__.py</code> files generating incorrectly for latest version</li> </ul>"},{"location":"home/CHANGELOG/#341","title":"[3.4.1]","text":""},{"location":"home/CHANGELOG/#fixed_16","title":"Fixed","text":"<ul> <li>If the endpoint specified a single non-pydantic (list/dict) body parameter, Cadwyn failed to serialize the body</li> </ul>"},{"location":"home/CHANGELOG/#340","title":"[3.4.0]","text":""},{"location":"home/CHANGELOG/#added_8","title":"Added","text":"<ul> <li><code>schema(...).validator(...).existed</code> and <code>schema(...).validator(...).didnt_exist</code> instructions for simplistic manipulation of validators</li> <li>Automatic deletion of validators when the fields they validate get deleted</li> <li><code>schema(...).field(...).didnt_have</code> for unsetting field attributes</li> <li>Improved support for <code>typing.Annotated</code> in schemas</li> <li>Full preservation of original abstract syntax trees for all field values and annotations</li> </ul>"},{"location":"home/CHANGELOG/#fixed_17","title":"Fixed","text":"<ul> <li>If the user wrote a wrong signature in a transformer decorated by <code>convert_request_to_next_version_for</code> or <code>convert_response_to_previous_version_for</code>, the text of the error suggested the wrong argument count and names</li> </ul>"},{"location":"home/CHANGELOG/#334","title":"[3.3.4]","text":""},{"location":"home/CHANGELOG/#fixed_18","title":"Fixed","text":"<ul> <li>Added backwards compatibility for FastAPI &lt; 0.106.0</li> </ul>"},{"location":"home/CHANGELOG/#333","title":"[3.3.3]","text":""},{"location":"home/CHANGELOG/#fixed_19","title":"Fixed","text":"<ul> <li>Guaranteed that it is impossible to release cadwyn with the wrong pydantic dependency</li> </ul>"},{"location":"home/CHANGELOG/#332","title":"[3.3.2]","text":""},{"location":"home/CHANGELOG/#fixed_20","title":"Fixed","text":"<ul> <li>Downgrade required version of verselect for backwards compatibility</li> </ul>"},{"location":"home/CHANGELOG/#331","title":"[3.3.1]","text":""},{"location":"home/CHANGELOG/#fixed_21","title":"Fixed","text":"<ul> <li>Removed lazy migrations as they were producing incorrect results when there were no migrations but when there were schema changes</li> <li>Added compatibility with fastapi&gt;=0.109.0</li> </ul>"},{"location":"home/CHANGELOG/#330","title":"[3.3.0]","text":""},{"location":"home/CHANGELOG/#fixed_22","title":"Fixed","text":"<ul> <li>If a user used a FastAPI/Starlette <code>StreamingResponse</code> or <code>FileResponse</code>, we still tried to access its <code>body</code> attribute which caused an <code>AttributeError</code></li> </ul>"},{"location":"home/CHANGELOG/#320","title":"[3.2.0]","text":""},{"location":"home/CHANGELOG/#added_9","title":"Added","text":"<ul> <li>Sponsors section to README and docs, along with Monite as our main and only current sponsor \u2728</li> </ul>"},{"location":"home/CHANGELOG/#313","title":"[3.1.3]","text":""},{"location":"home/CHANGELOG/#fixed_23","title":"Fixed","text":"<ul> <li>Switched to <code>better-ast-comments</code> because <code>ast-comments</code> had no license listed on pypi (even though its actual license was MIT) which caused some dependency checking tools to report it as unlicensed</li> </ul>"},{"location":"home/CHANGELOG/#312","title":"[3.1.2]","text":""},{"location":"home/CHANGELOG/#changed_7","title":"Changed","text":"<ul> <li>Migrate from black to ruff-format</li> </ul>"},{"location":"home/CHANGELOG/#fixed_24","title":"Fixed","text":"<ul> <li>A rare Pydantic 2 bug in internal body schema handling when it was applied too early, causing partially incomplete data to arrive to the handler</li> </ul>"},{"location":"home/CHANGELOG/#311","title":"[3.1.1]","text":""},{"location":"home/CHANGELOG/#fixed_25","title":"Fixed","text":"<ul> <li>Previously we did not pass <code>dependency_overrides_provider</code>, <code>response_model_exclude_unset</code> <code>response_model_exclude_defaults</code>, and <code>response_model_exclude_none</code> to <code>fastapi</code> which could cause erroneous behaviour during serialization in rare cases.</li> </ul>"},{"location":"home/CHANGELOG/#310","title":"[3.1.0]","text":""},{"location":"home/CHANGELOG/#added_10","title":"Added","text":"<ul> <li><code>module(...).had(import_=...)</code> construct for adding imports in older versions</li> <li>Codegen plugin system that allows easily customizing code generation for any purpose. It also significantly simplifies the core code of code generation</li> </ul>"},{"location":"home/CHANGELOG/#302","title":"[3.0.2]","text":""},{"location":"home/CHANGELOG/#fixed_26","title":"Fixed","text":"<ul> <li>If a user returned a FastAPI/Starlette <code>Response</code> with an empty body, we still tried to serialize it which caused an invalid response body</li> </ul>"},{"location":"home/CHANGELOG/#unreleased_1","title":"[Unreleased]","text":""},{"location":"home/CHANGELOG/#300","title":"[3.0.0]","text":""},{"location":"home/CHANGELOG/#added_11","title":"Added","text":"<ul> <li>Pydantic 2 support</li> <li>Expanded reference section to docs</li> <li>Contributor docs</li> <li>Expanded makefile commands</li> </ul>"},{"location":"home/CHANGELOG/#changed_8","title":"Changed","text":"<ul> <li>internal request representation is now done using an annotation</li> <li><code>latest_schemas_module</code> was renamed to <code>latest_schemas_package</code> everywhere</li> <li><code>api_version_var</code> in <code>VersionBundle</code> is now an optional argument instead of a required one</li> </ul>"},{"location":"home/CHANGELOG/#removed_2","title":"Removed","text":"<ul> <li><code>cadwyn.internal_body_representation_of</code> because it is now done using an annotation</li> </ul>"},{"location":"home/CHANGELOG/#234","title":"[2.3.4]","text":""},{"location":"home/CHANGELOG/#fixed_27","title":"Fixed","text":"<ul> <li><code>schema(...).field(...).had(ge=...)</code> for union fields previously raised an <code>AttributeError</code> on code generation</li> </ul>"},{"location":"home/CHANGELOG/#233","title":"[2.3.3]","text":""},{"location":"home/CHANGELOG/#fixed_28","title":"Fixed","text":"<ul> <li>Field ASTs not preserving the original structure when constrained fields were changed</li> </ul>"},{"location":"home/CHANGELOG/#added_12","title":"Added","text":"<ul> <li>Support for synchronous endpoints</li> </ul>"},{"location":"home/CHANGELOG/#232","title":"[2.3.2]","text":""},{"location":"home/CHANGELOG/#fixed_29","title":"Fixed","text":"<ul> <li>The bug where fields from parent schemas also appeared in child schemas</li> </ul>"},{"location":"home/CHANGELOG/#231","title":"[2.3.1]","text":""},{"location":"home/CHANGELOG/#changed_9","title":"Changed","text":"<ul> <li>Migrate from external verselect to stable verselect</li> </ul>"},{"location":"home/CHANGELOG/#230","title":"[2.3.0]","text":""},{"location":"home/CHANGELOG/#fixed_30","title":"Fixed","text":"<ul> <li>Previously whenever we generated routes, we wrapped all endpoints and callbacks in decorators for every version which caused stacktraces to be unnecessarily huge. Now there is only one wrapper for all versions</li> </ul>"},{"location":"home/CHANGELOG/#added_13","title":"Added","text":"<ul> <li><code>cadwyn.Cadwyn</code> class similar to <code>fastapi.FastAPI</code> that provides header routing and encapsulates all information about versioned routes</li> <li>Migrated from <code>fastapi-header-routing</code> to <code>verselect</code></li> <li><code>cadwyn.routing.VERSION_HEADER_FORMAT</code> from <code>verselect.routing</code></li> </ul>"},{"location":"home/CHANGELOG/#changed_10","title":"Changed","text":"<ul> <li><code>*versions</code> argument in <code>cadwyn.VersionBundle</code> is now split into a required positional-only <code>latest_version</code> and <code>*other_versions</code> to make it possible to see an invalid versionless definition statically. Note that it is not a breaking change because the presence of at least one version was also implicitly required before and would produce a failure at runtime</li> </ul>"},{"location":"home/CHANGELOG/#removed_3","title":"Removed","text":"<ul> <li><code>cadwyn.get_cadwyn_dependency</code> and <code>cadwyn.header</code> because it is fully replaced with <code>verselect</code></li> </ul>"},{"location":"home/CHANGELOG/#220","title":"[2.2.0]","text":""},{"location":"home/CHANGELOG/#added_14","title":"Added","text":"<ul> <li>Validation for the spelling of HTTP methods in <code>cadwyn.structure.endpoint</code>.</li> </ul>"},{"location":"home/CHANGELOG/#210","title":"[2.1.0]","text":""},{"location":"home/CHANGELOG/#added_15","title":"Added","text":"<ul> <li>A prototype of AST-based code generation where we try to keep as much of the old field/annotation structure as possible</li> </ul>"},{"location":"home/CHANGELOG/#205","title":"[2.0.5]","text":""},{"location":"home/CHANGELOG/#fixed_31","title":"Fixed","text":"<ul> <li><code>UploadFile</code> and forms have previously caused exceptions on request migration</li> </ul>"},{"location":"home/CHANGELOG/#204","title":"[2.0.4]","text":""},{"location":"home/CHANGELOG/#fixed_32","title":"Fixed","text":"<ul> <li><code>ContextVar[datetime.date]</code> being incompatible with <code>VersionBundle</code></li> </ul>"},{"location":"home/CHANGELOG/#203","title":"[2.0.3]","text":""},{"location":"home/CHANGELOG/#added_16","title":"Added","text":"<ul> <li>A note into reference docs about the paths specification in CLI</li> </ul>"},{"location":"home/CHANGELOG/#fixed_33","title":"Fixed","text":"<ul> <li>Custom body fields created by fastapi caused an exception. Now they are ignored</li> </ul>"},{"location":"home/CHANGELOG/#202","title":"[2.0.2]","text":""},{"location":"home/CHANGELOG/#added_17","title":"Added","text":"<ul> <li>A link to openapi discussion on enum expansion into docs/recipes</li> <li>A link to intercom's API versioning article into docs/theory</li> </ul>"},{"location":"home/CHANGELOG/#201","title":"[2.0.1]","text":""},{"location":"home/CHANGELOG/#fixed_34","title":"Fixed","text":"<ul> <li><code>generate_versioned_routers</code> did not alter <code>APIRoute.dependant.call</code>, <code>APIRoute.response_field</code>, and <code>APIRoute.secure_cloned_response_field</code> before which caused these fields to represent latest version on all generated versions. However, this was only a bug if the routes were later added into the app/router by hand instead of using <code>inherit_routes</code> or <code>add_api_route</code>.</li> </ul>"},{"location":"home/CHANGELOG/#200","title":"[2.0.0]","text":""},{"location":"home/CHANGELOG/#changed_11","title":"Changed","text":"<ul> <li><code>generate_versioned_routers</code> now accepts only one router instead of a sequence of routers to give us the ability to guarantee that the type of generated routers is the same as the type of the passed router.</li> </ul>"},{"location":"home/CHANGELOG/#140","title":"[1.4.0]","text":""},{"location":"home/CHANGELOG/#added_18","title":"Added","text":"<ul> <li>Theory section to docs</li> </ul>"},{"location":"home/CHANGELOG/#130","title":"[1.3.0]","text":""},{"location":"home/CHANGELOG/#added_19","title":"Added","text":"<ul> <li>Recipes documentation section</li> <li><code>schema(...).field(...).had(name=...)</code> functionality to rename fields</li> </ul>"},{"location":"home/CHANGELOG/#changed_12","title":"Changed","text":"<ul> <li>Tutorial example structure in tests</li> </ul>"},{"location":"home/CHANGELOG/#120-2023-10-16","title":"[1.2.0] - 2023-10-16","text":""},{"location":"home/CHANGELOG/#added_20","title":"Added","text":"<ul> <li><code>cadwyn.main._Cadwyn</code> experimental private class for automatically adding the header dependency and managing all objects related to versioning</li> </ul>"},{"location":"home/CHANGELOG/#removed_4","title":"Removed","text":"<ul> <li><code>cadwyn.header_routing</code> which only had experimental private functions</li> </ul>"},{"location":"home/CHANGELOG/#fixed_35","title":"Fixed","text":"<ul> <li>Route callbacks didn't get migrated to versions with their parent routes</li> </ul>"},{"location":"home/CHANGELOG/#110-2023-10-13","title":"[1.1.0] - 2023-10-13","text":""},{"location":"home/CHANGELOG/#added_21","title":"Added","text":"<ul> <li><code>ignore_coverage_for_latest_aliases</code> argument to <code>generate_code_for_versioned_packages</code> which controls whether we add \"a pragma: no cover\" comment to the star imports in the generated version of the latest module. It is True by default.</li> </ul>"},{"location":"home/CHANGELOG/#103-2023-10-10","title":"[1.0.3] - 2023-10-10","text":""},{"location":"home/CHANGELOG/#fixed_36","title":"Fixed","text":"<ul> <li>Add back the approach where the first version being an alias to latest in codegen</li> </ul>"},{"location":"home/CHANGELOG/#102-2023-10-09","title":"[1.0.2] - 2023-10-09","text":""},{"location":"home/CHANGELOG/#fixed_37","title":"Fixed","text":"<ul> <li>Add current working dir to <code>sys.path</code> when running code generation through CLI</li> <li>Use <code>exclude_unset</code> when migrating the body of a request to make sure that users' <code>exclude_unset</code> logic gets preserved</li> </ul>"},{"location":"home/CHANGELOG/#101-2023-10-09","title":"[1.0.1] - 2023-10-09","text":""},{"location":"home/CHANGELOG/#fixed_38","title":"Fixed","text":"<ul> <li>Pass first argument in <code>typer.Argument</code> to prevent errors on older typer versions</li> </ul>"},{"location":"home/CHANGELOG/#100-2023-10-09","title":"[1.0.0] - 2023-10-09","text":""},{"location":"home/CHANGELOG/#added_22","title":"Added","text":"<ul> <li>Command-line interface capable of running code-generation and outputting version info</li> <li>Internal request schema which gives us all the functionality we could ever need to migrate request bodies forward without any complexity of the prior solution</li> <li><code>_get_versioned_router</code> and experimental header routing with it (by @tikon93). Note that the interface for this feature will change in the future</li> </ul>"},{"location":"home/CHANGELOG/#changed_13","title":"Changed","text":"<ul> <li>Renamed <code>cadwyn.regenerate_dir_to_all_versions</code> to <code>cadwyn.generate_code_for_versioned_packages</code></li> <li>Renamed <code>cadwyn.generate_all_router_versions</code> to <code>cadwyn.generate_versioned_routers</code></li> </ul>"},{"location":"home/CHANGELOG/#removed_5","title":"Removed","text":"<ul> <li><code>unions</code> directory and all logic around it (replaced by internal request schema)</li> <li><code>FillablePrivateAttr</code> and all logic around it (replaced by internal request schema)</li> <li><code>schema(...).property</code> constructor and all logic around it (replaced by internal request schema)</li> <li>Special-casing for code generation of package with latest version using star imports from latest (replaced by internal request schema)</li> </ul>"},{"location":"home/CONTRIBUTING/","title":"Contribution Guide","text":""},{"location":"home/CONTRIBUTING/#setting-up-the-environment","title":"Setting up the environment","text":"<ul> <li>The lowest currently supported version is Python 3.10. You can use pyenv to manage multiple Python versions on your system.</li> <li> <p>We maintain a Makefile with several commands to help with common tasks.</p> </li> <li> <p>Install Poetry</p> </li> <li>Run <code>poetry install --all-extras</code> to create a virtual environment and install the required development dependencies</li> <li>Install pre-commit</li> <li>Run <code>pre-commit install --install-hooks</code> to install pre-commit hooks</li> </ul> <p>Many modern IDEs like PyCharm or VS Code will enable the Poetry-managed virtualenv that is created in step 2 for you automatically. If your IDE/editor does not offer this functionality, then you will need to manually activate the virtualenv yourself. Otherwise you may encounter errors or unexpected behaviour when trying to run the commands referenced within this document.</p> <p>To activate the virtualenv, please consult Poetry's documentation on working with virtual environments.</p> <p>The rest of this document will assume this environment is active wherever commands are referenced.</p>"},{"location":"home/CONTRIBUTING/#code-contributions","title":"Code contributions","text":""},{"location":"home/CONTRIBUTING/#workflow","title":"Workflow","text":"<ol> <li>Fork the Cadwyn repository</li> <li>Clone your fork locally with git</li> <li>Set up the environment</li> <li>Make your changes</li> <li>Commit your changes to git.</li> <li>Open a pull request. Give the pull request a descriptive title indicating what it changes.</li> </ol>"},{"location":"home/CONTRIBUTING/#guidelines-for-writing-code","title":"Guidelines for writing code","text":"<ul> <li>Code should be Pythonic and zen</li> <li>All code should be fully typed. This is enforced via ruff but the type hinting itself will be enforced by pyright in the future.</li> <li>When requiring complex types, use a type alias.</li> <li>If something cannot be typed correctly due to a limitation of the type checkers, you may use typing.cast to rectify the situation. However, you should only use as a last resort if you've exhausted all other options of type narrowing, such as isinstance() checks and type guards</li> <li>You may use <code>pyright: ignore</code> if you ensured that a line is correct, but pyright has issues with it.</li> <li>If you are adding or modifying existing code, ensure that it's fully tested. 100% test coverage is mandatory, and will be checked on the PR using Github Actions</li> <li>When adding a new public interface, it has to be included in the concept documentation located in <code>docs/concepts.md</code>. If applicable, add or modify examples in the docs related to the new functionality implemented.</li> </ul>"},{"location":"home/CONTRIBUTING/#writing-and-running-tests","title":"Writing and running tests","text":"<p>Tests are contained within the <code>tests</code> directory, and follow roughly the same directory structure as the <code>cadwyn</code> module. If you are adding a test case, it should be located within the correct submodule of <code>tests</code>. E.g. tests for <code>cadwyn/codegen.py</code> reside in <code>tests/codegen</code>.</p> <p>The <code>Makefile</code> includes several commands for running tests:</p> <ul> <li><code>make test</code> to run tests located in <code>tests</code></li> <li><code>make supertest</code> will run tests on both pydantic 1 and pydantic 2</li> </ul>"},{"location":"home/CONTRIBUTING/#running-type-checkers","title":"Running type checkers","text":"<p>We use pyright to enforce type safety. You can run it with:</p> <p><code>pyright .</code></p>"},{"location":"home/CONTRIBUTING/#project-documentation","title":"Project documentation","text":"<p>The documentation is located in the <code>/docs</code> directory and is all in Markdown.</p>"},{"location":"home/CONTRIBUTING/#docs-theme-and-appearance","title":"Docs theme and appearance","text":"<p>We welcome contributions that enhance / improve the appearance and usability of the docs. We use mkdocs-material If you wish to contribute to the docs style / setup, or static site generation, you should consult the theme docs as a first step.</p>"},{"location":"home/CONTRIBUTING/#running-the-docs-locally","title":"Running the docs locally","text":"<p>Then you can serve the documentation with <code>mkdocs serve</code></p>"},{"location":"home/CONTRIBUTING/#writing-and-editing-docs","title":"Writing and editing docs","text":"<p>We welcome contributions that enhance / improve the content of the docs. Feel free to add examples, clarify text, restructure the docs, etc., but make sure to follow these guidelines:</p> <ul> <li>Write text in idiomatic english, using simple language</li> <li>Opt for Oxford commas when listing a series of terms</li> <li>Keep examples simple and self contained</li> <li>Provide links where applicable</li> </ul>"},{"location":"how_to/","title":"How to...","text":"<p>This section serves as a guide to help you create new versions effectively and maintain your old versions with ease. It consists of a collection of scenarios for different types of breaking changes.</p> <p>To follow this guide, choose a type of an entity that you'd like to alter (an endpoint, a schema, etc), find the respective article, and follow its instructions. Repeat for every breaking change you would like to do.</p> <p>The guide will assume this directory structure.</p> <p>Versioning is a complex topic with more pitfalls than you'd expect so please: do not try to skip this guide. Otherwise, your code will quickly get unmaintainable. Please also note that any of these scenarios can be combined in any way even within a single version change, though it's recommended to keep the version changes atomic as described in methodology section.</p>"},{"location":"how_to/change_business_logic/","title":"Change the business logic in a new version","text":"<p>First, ask yourself: are you sure there really needs to be a behavioral change? Are you sure it is not possible to keep the same logic for both versions? Or at least make the behavior depend on the received data? Behavioral changes (or side effects) are the least maintainable part of almost any versioning approach. They produce the largest footprint on your code so if you are not careful -- your logic will be littered with version checks.</p> <p>But if you are certain that you need to make a breaking behavioral change, Cadwyn has all the tools to minimize its impact as much as possible.</p>"},{"location":"how_to/change_business_logic/#calling-endpoint-causes-unexpected-data-modifications","title":"Calling endpoint causes unexpected data modifications","text":"<p>You'd use an <code>if statement</code> with a side effect.</p>"},{"location":"how_to/change_business_logic/#calling-endpoint-doesnt-cause-expected-data-modifications","title":"Calling endpoint doesn't cause expected data modifications","text":"<p>You'd use an <code>if statement</code> with a side effect.</p>"},{"location":"how_to/change_business_logic/#calling-endpoint-doesnt-cause-expected-additional-actions-eg-webhooks","title":"Calling endpoint doesn't cause expected additional actions (e.g. Webhooks)","text":"<p>You'd use an <code>if statement</code> with a side effect.</p>"},{"location":"how_to/change_business_logic/#errors","title":"Errors","text":""},{"location":"how_to/change_business_logic/#change-the-status-code-or-a-message-in-an-http-error","title":"Change the status code or a message in an HTTP error","text":"<p>You can migrate anything about the error in a version change.</p>"},{"location":"how_to/change_business_logic/#introduce-a-new-error-or-remove-an-old-error","title":"Introduce a new error or remove an old error","text":"<p>You'd use an <code>if statement</code> with a side effect.</p>"},{"location":"how_to/change_endpoints/","title":"Change endpoints in a new version","text":""},{"location":"how_to/change_endpoints/#add-a-new-endpoint","title":"Add a new endpoint","text":"<p>It is not a breaking change so it's recommended to simply add it to all versions. If you believe that you still need it, you can use the following migration.</p>"},{"location":"how_to/change_endpoints/#delete-an-old-endpoint","title":"Delete an old endpoint","text":"<p>See concepts</p>"},{"location":"how_to/change_endpoints/#change-an-attribute-of-an-endpoint","title":"Change an attribute of an endpoint","text":"<p>Changing a \"decoratory\" attribute such as description or summary is generally not a breaking change and should just be applied to all versions.</p> <p>However, you are still free to change almost any attribute of an endpoint in the old version. See concepts docs.</p>"},{"location":"how_to/change_endpoints/#rename-an-endpoint","title":"Rename an endpoint","text":"<p>Renaming endpoints is the same as changing their \"path\" attribute. See concepts docs for more details.</p>"},{"location":"how_to/change_openapi_schemas/add_field/","title":"Add a field to openapi schemas","text":""},{"location":"how_to/change_openapi_schemas/add_field/#to-response-schema","title":"To response schema","text":"<p>Let's say that we decided to expose the creation date of user's account with a <code>created_at</code> field in our API. This is not a breaking change so a new version is completely unnecessary. However, if you believe that you absolutely have to make a new version, then you can simply follow the recommended approach below but add a version change with field didnt exist instruction.</p> <p>The recommended approach:</p> <ol> <li>Add <code>created_at</code> field into <code>data.head.users.UserResource</code></li> <li>Regenerate the versioned schemas</li> </ol> <p>Now you have everything you need at your disposal: field <code>created_at</code> is available in all versions and your users do not even need to do any extra actions. Just make sure that the data for it is available in all versions too. If it's not: make the field optional.</p>"},{"location":"how_to/change_openapi_schemas/add_field/#to-both-request-and-response-schemas","title":"To both request and response schemas","text":""},{"location":"how_to/change_openapi_schemas/add_field/#field-is-optional","title":"Field is optional","text":"<p>Let's say we want our users to be able to specify a middle name but it is nullable. It is not a breaking change so no new version is necessary whether it is requests or responses.</p> <p>The recommended approach:</p> <ol> <li>Add a nullable <code>middle_name</code> field into <code>data.head.users.BaseUser</code></li> <li>Regenerate the versioned schemas</li> </ol>"},{"location":"how_to/change_openapi_schemas/add_field/#field-is-required","title":"Field is required","text":""},{"location":"how_to/change_openapi_schemas/add_field/#with-compatible-default-value-in-older-versions","title":"With compatible default value in older versions","text":"<p>Let's say that our users had a field <code>country</code> that defaulted to <code>USA</code> but our product is now used well beyond United States so we want to make this field required in the HEAD version.</p> <ol> <li>Remove <code>default=\"US\"</code> from <code>data.head.users.UserCreateRequest</code></li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    convert_request_to_next_version_for,\n)\nfrom data.head.users import UserCreateRequest, UserResource\n\n\nclass MakeUserCountryRequired(VersionChange):\n    description = 'Make user country required instead of the \"USA\" default'\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest).field(\"country\").had(default=\"USA\"),\n    )\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def add_default_value_to_country_field_in_request(request: RequestInfo):\n        request.body[\"country\"] = request.body.get(\"country\", \"USA\")\n</code></pre> </li> <li> <p>Add this migration into the version bundle:</p> <pre><code># versions/__init__.py\n\nfrom cadwyn.structure import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom data import head\nfrom .v2001_01_01 import MakeUserCountryRequired\n\nversion_bundle = VersionBundle(\n    HeadVersion(),\n    Version(date(2001, 1, 1), MakeUserCountryRequired),\n    Version(date(2000, 1, 1)),\n    head_schemas_package=head,\n)\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>That's it! Our old schemas will now contain a default but in HEAD country will be required. You might notice a weirdness: if we set a default in the old version, why would we also write a migration? That's because of a sad implementation detail of pydantic that prevents us from using defaults from old versions.</p>"},{"location":"how_to/change_openapi_schemas/add_field/#with-incompatible-default-value-in-older-versions","title":"With incompatible default value in older versions","text":"<p>Let's say that we want to add a required field <code>phone</code> to our users. However, older versions did not have such a field at all. This means that the field is going to be nullable (or nonexistent) in the old versions but required in the HEAD version. This also means that older versions contain a wider type (<code>str | None</code>) than the HEAD version (<code>str</code>). So when we try to migrate request bodies from the older versions to HEAD -- we might receive a <code>ValidationError</code> because <code>None</code> is not an acceptable value for <code>phone</code> field in the new version. Whenever we have a problem like this, when older version contains more data or a wider type set of data,  we can simply define a wider type in our HEAD version and then narrow it in latest.</p> <p>So we will make <code>phone</code> nullable in HEAD, then make it required in <code>latest</code>, and then make it nullable again in older versions, thus making it possible to convert all of our requests to HEAD.</p> <ol> <li>Add <code>phone</code> field of type <code>str | None</code> to <code>data.head.users.BaseUser</code></li> <li>Add <code>phone</code> field of type <code>str | None</code> with a <code>default=None</code> to <code>data.head.users.UserResource</code> because all users created with older versions of our API won't have phone numbers.</li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code> which will make sure that <code>phone</code> is not nullable in 2001_01_01:</p> <pre><code>from cadwyn.structure import VersionChange, schema\nfrom data.head.users import UserCreateRequest\n\n\nclass MakePhoneNonNullableInLatest(VersionChange):\n    description = (\n        \"Make sure the phone is nullable in the HEAD version to support \"\n        \"versions older than 2001_01_01 where it became non-nullable\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest).field(\"phone\").had(type=str),\n        schema(UserCreateRequest).field(\"phone\").didnt_have(\"default\"),\n    )\n</code></pre> </li> <li> <p>Add the following version change to <code>versions.v2001_01_01</code> (right under the version change above) which will make sure that <code>phone</code> is nullable in 2000_01_01:</p> <pre><code>class AddPhoneToUser(VersionChange):\n    description = (\n        \"Add a required phone field to User to allow us to do 2fa and to \"\n        \"make it possible to verify new user accounts using an sms.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest)\n        .field(\"phone\")\n        .had(type=str | None, default=None),\n    )\n</code></pre> </li> <li> <p>Add both migrations into our VersionBundle:</p> <pre><code># versions/__init__.py\nfrom cadwyn.structure import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom data import head\nfrom .v2001_01_01 import MakePhoneNonNullableInLatest, AddPhoneToUser\n\n\nversion_bundle = VersionBundle(\n    HeadVersion(MakePhoneNonNullableInLatest),\n    Version(date(2001, 1, 1), AddPhoneToUser),\n    Version(date(2000, 1, 1)),\n    head_schemas_package=head,\n)\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>See how we didn't remove the <code>phone</code> field from old versions? Instead, we allowed a nullable <code>phone</code> field to be passed into both old <code>UserResource</code> and old <code>UserCreateRequest</code>. This gives our users new functionality without needing to update their API version! It is one of the best parts of Cadwyn's approach: our users can get years worth of updates without switching their API version and without their integration getting broken.</p>"},{"location":"how_to/change_openapi_schemas/change_field_type/","title":"Change field type in schemas","text":""},{"location":"how_to/change_openapi_schemas/change_field_type/#incompatibly-change-the-type","title":"Incompatibly change the type","text":"<p>If your data had a type <code>int</code> and you want to change it to an <code>str</code> in a new version, then your data from the new version can easily break the responses of the old versions, thus making it data versioning, not API versioning -- as you are versioning the fundamental structures the user is operating on instead of just the API.</p>"},{"location":"how_to/change_openapi_schemas/change_field_type/#expand-the-type","title":"Expand the type","text":"<p>Let's say that our clients could choose a <code>role</code> for our users. Originally, it was only possible to choose <code>admin</code> or <code>regular</code> but we would like to expand it to <code>moderator</code> which has all the powers of an admin except that moderators cannot assign other admins.</p> <p>This is not a breaking change in terms of requests but it can be a breaking change in terms of responses.</p> <p>So if you do consider it a breaking change in terms of responses, you should do the following:</p> <ol> <li>Add <code>moderator</code> value into <code>data.head.users.BaseUserRoleEnum</code></li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    enum,\n    convert_response_to_previous_version_for,\n    ResponseInfo,\n)\nfrom data.head.users import UserRoleEnum, UserResource\nimport datetime\n\n\nclass AddModeratorRoleToUser(VersionChange):\n    description = (\n        \"Add 'moderator' role to users that represents an admin that \"\n        \"cannot create or remove other admins. This allows for a \"\n        \"finer-grained permission control.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        enum(UserRoleEnum).didnt_have(\"moderator\"),\n    )\n\n    @convert_response_to_previous_version_for(UserResource)\n    def change_moderator_to_regular(response: ResponseInfo):\n        if response.body[\"role\"] == \"moderator\":\n            response.body[\"role\"] = \"regular\"\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>We convert moderators to regulars in older versions because it is a safer choice for our users.</p>"},{"location":"how_to/change_openapi_schemas/change_field_type/#why-enum-expansion-is-a-breaking-change-for-responses","title":"Why enum expansion is a breaking change for responses","text":"<p>Let's that our schema includes a list that contains euros and/or dollars. Using our framework for unmarshalling JSON, we take the JSON string and try to convert it into the list of euros and/or dollars. If we suddenly see Georgian lari there -- our unmarshalling framework freaks out because the list is not what it expected, which makes adding an enum value a breaking change when you have a list of items.</p> <p>To be more precise: If I, as a client, expect <code>Array&lt;Euro | Dollar&gt;</code>, then <code>Array&lt;Euro&gt;</code> would be a compatible response and <code>Array&lt;Dollar&gt;</code> would be a compatible response BUT <code>Array&lt;Euro | Dollar | Lari&gt;</code> would be an incompatible response. That is the case because <code>Array&lt;Euro | Dollar | Lari&gt;</code> is a not a subtype of <code>Array&lt;Euro | Dollar&gt;</code> while <code>Array&lt;Euro&gt;</code> is.</p> <p>In a sense, extending an enum that has <code>USD</code> with <code>USD | EUR</code> is equivalent to turning an <code>int</code> field into an <code>int | str</code> field, which is a breaking change. Hence extending an enum is often a breaking change and thus we might not need to solve this problem at all.</p> <p>Additional resources:</p> <ul> <li>https://github.com/OAI/OpenAPI-Specification/issues/1552</li> <li>https://users.rust-lang.org/t/solved-is-adding-an-enum-variant-a-breaking-change/26721/5</li> <li>https://github.com/graphql/graphql-js/issues/968</li> <li>https://medium.com/@jakob.fiegerl/java-jackson-enum-de-serialization-with-rest-backward-compatibility-9c3ec85ac13d</li> </ul> <p>In these sections, we'll be working with our user's response model: <code>data.head.users.UserResource</code>. Note that the main theme here is \"Will I be able to serialize this change to any of my versions?\" as any change to responses can make them incompatible with the data in your database.</p>"},{"location":"how_to/change_openapi_schemas/change_field_type/#narrow-the-type","title":"Narrow the type","text":"<p>Let's say that previously users could specify their date of birth as a datetime instead of a date. We wish to rectify that. We can solve this by making it a datetime in HEAD version, converting it to date in latest version, and then making it a datetime again in the old versions. So whenever we receive a request in an old version, it will get converted to HEAD version where it is a datetime. And whenever we receive a request in latest version, it will also be converted to HEAD where date will simply be casted to datetime with time = 00:00:00.</p> <ol> <li>Continue storing <code>date_of_birth</code> as a datetime in your database to avoid breaking any old behavior</li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code> which will turn <code>date_of_birth</code> into a date in 2001_01_01. Note how we use the validator for making sure that <code>date_of_birth</code> is converted to date in the latest version. It is only necessary in Pydantic 2 because it has no implicit casting from datetime to date. Note also how we use strings for types: this is not always necessary; it just allows you to control specifically how Cadwyn is going to render your types. Most of the time you won't need to use strings for types.</p> <pre><code>from cadwyn.structure import VersionChange, schema\nfrom pydantic import validator\nfrom data.head.users import BaseUser\nimport datetime\n\n\n@validator(\"date_of_birth\", pre=True)\ndef convert_date_of_birth_to_date(cls, v: datetime.date | datetime.datetime):\n    if isinstance(v, datetime.datetime):\n        return v.date()\n    return v\n\n\nclass ChangeDateOfBirthToDateInUserInLatest(VersionChange):\n    description = (\n        \"Change 'BaseUser.date_of_birth' field type to datetime in HEAD \"\n        \"to support versions and data before 2001-01-01. \"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser).field(\"date_of_birth\").had(type=\"datetime.date\"),\n        # This step is only necessary in Pydantic 2 because datetime won't be converted\n        # to date automatically.\n        schema(BaseUser).validator(convert_date_of_birth_to_date).existed,\n    )\n</code></pre> </li> <li> <p>Add the following version change to <code>versions.v2001_01_01</code> (right under the version change above) which will make sure that <code>date_of_birth</code> is a datetime in 2000_01_01:</p> <pre><code>class ChangeDateOfBirthToDateInUser(VersionChange):\n    description = (\n        \"Change 'User.date_of_birth' field type to date instead of \"\n        \"a datetime because storing the exact time is unnecessary.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser).field(\"date_of_birth\").had(type=\"datetime.datetime\"),\n        schema(BaseUser).validator(convert_date_of_birth_to_date).didnt_exist,\n    )\n</code></pre> </li> <li> <p>Add both migrations into our VersionBundle:</p> <pre><code># versions/__init__.py\nfrom cadwyn.structure import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom data import head\nfrom .v2001_01_01 import MakePhoneNonNullableInLatest, AddPhoneToUser\n\n\nversion_bundle = VersionBundle(\n    HeadVersion(ChangeDateOfBirthToDateInUserInLatest),\n    Version(date(2001, 1, 1), ChangeDateOfBirthToDateInUser),\n    Version(date(2000, 1, 1)),\n    head_schemas_package=head,\n)\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>This whole process was a bit complex so let us break it down a little:</p> <ol> <li><code>date_of_birth</code> field is a datetime in HEAD, a date in 2001, and a datetime again in 2000.</li> <li>We needed some way to keep the 2000 behavior without allowing users in 2001 to use it. Cadwyn always converts all requests to the HEAD version so:<ul> <li>When we receive user creation requests from 2001, we convert them directly to HEAD, and pydantic casts date to datetime without any issue</li> <li>When we receive user get requests from 2001, we convert them directly from HEAD to latest, and our validator casts datetime to date (note that pydantic 1 would be able to do it even without a validator)</li> <li>When we receive user creation requests from 2000, we convert them directly to HEAD -- they have the same type for <code>date_of_birth</code> so it is easy to Cadwyn</li> <li>When we receive user get requests from 2000, we convert them directly from HEAD to 2000 -- they have the same type for <code>date_of_birth</code> so it is easy to Cadwyn</li> </ul> </li> </ol> <p>All of these interactions are done internally by Cadwyn. As you see, the process is more than straightforward: requests are converted to HEAD, and responses are converted from HEAD.</p> <p>Thus, we have kept old behavior, added new constrained behavior, and minimized the impact on our business logic as business logic simply doesn't know that <code>date_of_birth</code> in requests is ever a date and that <code>date_of_birth</code> in responses is ever a date. All of this information is hidden in our migration.</p> <p>A very important point here is that unlike schemas, routes, and business logic -- the migrations we wrote will likely never need to change because they describe the fundamental differences between the API versions, and these differences cannot be changed in the future because that would defeat the purpose of API versioning. This makes migrations effectively immutable and consequently very cheap to support.</p>"},{"location":"how_to/change_openapi_schemas/changing_constraints/","title":"Change field constraints or validators in openapi schemas","text":""},{"location":"how_to/change_openapi_schemas/changing_constraints/#add-or-narrow-constraints","title":"Add or narrow constraints","text":"<p>Let's say that we previously allowed users to have a name of arbitrary length but now we want to limit it to 250 characters because we are worried that some users will be using inadequate lengths. You can't do this easily: if you simply add a <code>max_length</code> constraint to <code>User.name</code> -- the existing data in your database might become incompatible with this field in <code>UserResource</code>. So as long as incompatible data is there or can get there from some version -- you cannot add such a constraint to your responses. However, you can add it to your requests to prevent the creation of new user accounts with long names.</p> <ol> <li> <p>Change <code>max_length</code> of <code>data.v2001_01_01.users.UserCreateRequest.name</code> to 250 by adding the following migration to <code>versions.v2001_01_01</code>. We do this instead of just adding the constraint to HEAD to make sure that old requests will get converted to HEAD successfully -- without facing the constraint:</p> <pre><code>from cadwyn.structure import VersionChange, schema\nfrom data.head.users import UserCreateRequest\n\n\nclass AddLengthConstraintToNameInLatest(VersionChange):\n    description = (\n        \"Remove the max_length constraint from the HEAD version to support \"\n        \"versions older than 2001_01_01 where it did not have the constraint.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest).field(\"name\").had(max_length=250),\n    )\n</code></pre> </li> <li> <p>Then add this migration right under it into the same file:</p> <pre><code>class AddMaxLengthConstraintToUserNames(VersionChange):\n    description = (\n        \"Add a max length of 250 to user names when creating new users \"\n        \"to prevent overly large names from being used.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest).field(\"name\").didnt_have(\"max_length\"),\n    )\n</code></pre> </li> <li> <p>Add both of these migrations into the version bundle:</p> <pre><code># versions/__init__.py\n\nfrom cadwyn.structure import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom data import head\nfrom .v2001_01_01 import (\n    AddLengthConstraintToNameInLatest,\n    AddMaxLengthConstraintToUserNames,\n)\n\nversion_bundle = VersionBundle(\n    HeadVersion(AddLengthConstraintToNameInLatest),\n    Version(date(2001, 1, 1), AddMaxLengthConstraintToUserNames),\n    Version(date(2000, 1, 1)),\n    head_schemas_package=head,\n)\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>So our HEAD version does not have this constraint, our latest does, and earlier versions do not.</p> <ul> <li>Requests from 2000 will be converted directly to HEAD and will not face this constraint because HEAD does not have it</li> <li>Requests from 2001 will first be validated by 2001 schemas with this constraint, and then will be converted to HEAD too</li> </ul> <p>Note, however, that anyone using the old API versions will will still be able to use arbitrary length names in older API versions. If you want to prevent that, then the correct approach would instead be the following:</p> <ol> <li>Check whether any users have names longer than 250 characters. If there are few or no users that have such long names, then it may make sense to skip step 1. The other steps, however, cannot be skipped if you want to guarantee that your API gives no 500s at any point in the process.</li> <li>Issue a 3-6 month warning to all users stating that you will make a breaking change affecting older versions. Mention that you will truncate old names that are longer than 250 characters and that users will no longer be able to create such long names even in old API versions.</li> <li>After the deadline, add a <code>max_length</code> constraint to <code>data.head.users.UserCreateRequest.name</code></li> <li>Regenerate the versioned schemas</li> <li>Release it to production</li> <li>Truncate all names that are too long in the database (preferably using a migration and a separate release)</li> <li>Remove the <code>max_length</code> constraint from <code>data.head.users.UserCreateRequest.name</code></li> <li>Add the <code>max_length</code> constraint to <code>data.head.users.BaseUser.name</code></li> <li>Regenerate the versioned schemas</li> </ol> <p>This process seems quite complex but it's not Cadwyn-specific: if you want to safely and nicely version for your users, you will have to follow such a process even if you don't use any versioning framework at all.</p>"},{"location":"how_to/change_openapi_schemas/changing_constraints/#remove-or-expand-constraints","title":"Remove or expand constraints","text":"<p>Let's say that we previously only allowed users to have a name of length 50 but now we want to allow names of length 250 too. It does not make sense to add this to a new API version. Just add it into all API versions because it is not a breaking change.</p> <p>The recommended approach:</p> <ol> <li>Change <code>max_length</code> of <code>data.head.users.BaseUser.name</code> to 250</li> <li>Regenerate the versioned schemas</li> </ol> <p>However, sometimes it can be considered a breaking change if a large portion of your users use your system to verify their data and rely on your system to return status code <code>422</code> if this field is invalid. If that's the case, use the same approach as in constraint addition but use <code>schema(UserCreateRequest).field(\"name\").had(max_length=50)</code> instead.</p>"},{"location":"how_to/change_openapi_schemas/changing_constraints/#add-or-remove-validators","title":"Add or remove validators","text":"<p>The same approach as above could be used to add or remove pydantic validator functions using validator code generation. Note that adding validators is the same as narrowing or adding constraints, which means that the same trick as above should be used.</p>"},{"location":"how_to/change_openapi_schemas/remove_field/","title":"Remove a field from openapi schemas","text":""},{"location":"how_to/change_openapi_schemas/remove_field/#from-response","title":"From response","text":"<p>Let's say that our API has a mandatory <code>UserResource.date_of_birth</code> field. Let's also say that our API has previously exposed user's zodiac sign. Our analysts have decided that it does not make sense to store or send this information as it does not affect the functionality and can be inferred from date of birth.</p> <ol> <li>Remove <code>zodiac_sign</code> field from <code>data.head.users.UserResource</code></li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn.structure import VersionChange, schema\nfrom data.head.users import UserResource\nfrom pydantic import Field\n\n\nclass RemoveZodiacSignFromUser(VersionChange):\n    description = (\n        \"Remove 'zodiac_sign' field from UserResource because \"\n        \"it can be inferred from user's date of birth and because \"\n        \"only a small number of users has utilized it.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserResource)\n        .field(\"zodiac_sign\")\n        .existed_as(type=str, info=Field(description=\"User's magical sign\")),\n    )\n</code></pre> </li> <li> <p>Add this migration into the version bundle:</p> <pre><code># versions/__init__.py\n\nfrom cadwyn.structure import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom data import head\nfrom .v2001_01_01 import RemoveZodiacSignFromUser\n\nversion_bundle = VersionBundle(\n    HeadVersion(),\n    Version(date(2001, 1, 1), RemoveZodiacSignFromUser),\n    Version(date(2000, 1, 1)),\n    head_schemas_package=head,\n)\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>Thanks to the version change above, your old schemas will now include <code>zodiac_sign</code> field but your new schemas will stay the same. Don't remove the zodiac business logic from your router because the old version will still need it. So you always return the zodiac sign but the schemas of the latest version will ignore it.</p> <p>You can remove the logic for calculating and returning the zodiac sign after version <code>2000-01-01</code> gets deleted.</p>"},{"location":"how_to/change_openapi_schemas/remove_field/#from-both-request-and-response","title":"From both request and response","text":""},{"location":"how_to/change_openapi_schemas/remove_field/#optional-field","title":"Optional field","text":"<p>Let's say that we had a nullable <code>middle_name</code> field but we decided that it does not make sense anymore and want to remove it now from both requests and responses. This means that a user from an old version will still be able to pass it while the user from a new version will not. We can solve this by having this field in our HEAD, removing it from our latest version but keeping it in all older versions:</p> <ol> <li>Keep storing <code>middle_name</code> in your database in order to support old versions</li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code> to remove <code>middle_name</code> from the latest version:</p> <pre><code>from cadwyn.structure import VersionChange, schema\nfrom data.head.users import BaseUser\n\n\nclass RemoveMiddleNameFromLatestVersion(VersionChange):\n    description = (\n        \"Remove 'User.middle_name' from latest but keep it in HEAD \"\n        \"to support versions before 2001-01-01.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser).field(\"middle_name\").didnt_exist,\n    )\n</code></pre> </li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code> to leave support for <code>middle_name</code> in the older versions:</p> <pre><code>from cadwyn.structure import VersionChange, schema\nfrom data.head.users import BaseUser\n\n\nclass RemoveMiddleNameFromUser(VersionChange):\n    description = \"Remove 'User.middle_name' field\"\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser)\n        .field(\"middle_name\")\n        .existed_as(\n            type=str | None, description=\"User's Middle Name\", default=None\n        ),\n    )\n</code></pre> </li> <li> <p>Add these migrations into the version bundle:</p> <pre><code># versions/__init__.py\n\nfrom cadwyn.structure import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom data import head\nfrom .v2001_01_01 import RemoveZodiacSignFromUser\n\nversion_bundle = VersionBundle(\n    HeadVersion(RemoveMiddleNameFromLatestVersion),\n    Version(date(2001, 1, 1), RemoveMiddleNameFromUser),\n    Version(date(2000, 1, 1)),\n    head_schemas_package=head,\n)\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol> <p>We added a new version with a breaking change but neither the HEAD schema that we use in business logic, neither has the business logic itself have changed one bit.</p>"},{"location":"how_to/change_openapi_schemas/remove_field/#required-field","title":"Required field","text":"<p>There are two main cases with required fields:</p> <ol> <li>Remove a required field with a simple fake default (created_at)</li> <li>Remove a required field with an impossible default (tax id)</li> </ol> <p>The first one is simple to solve: just use the approach above but use a <code>default_factory=datetime.datetime.now</code> instead of <code>default=None</code>.</p> <p>Now what about case 2?</p> <p>Let's say that you have company resources in your system. Let's also say that each company has a <code>tax_id</code> and now you would like to remove the <code>tax_id</code> field or make it optional. If <code>tax_id</code> was required in your responses, you can't really do this with traditional API versioning because you cannot come up with a sane non-null default for <code>tax_id</code>. It is a case of data versioning where you try to make an API version that is inconsistent with other API versions in terms of its data. You deal with this using one of the following approaches:</p> <ol> <li>Talk to your users. In any API versioning problem, talking to your users is the best first step. See whether this is actually a breaking change for them. Maybe only a small subset of your users is using this field and you can migrate this subset manually without much investment, which will allow you to make the breaking changes without breaking anyone's API. Though this approach becomes impossible to use once you get a lot of clients.</li> <li>Issue a warning to your users that <code>tax_id</code> is going to become optional in all API versions in <code>N</code> months and then make it so. This will allow you to avoid data versioning and your users will have a grace period to fix their issues. Then you can simply follow the approach above.</li> <li>Release a <code>V2</code> version of your API which users will have to migrate their data to. This is a drastic approach and you should only reserve it for extreme cases but it is a correct way to represent data versioning.</li> <li>Disallow the new version (2001-01-01) to be used alongside older versions and disallow users to migrate to older versions after they have migrated to 2001-01-01. Then you can simply follow the approach above. This is a dirty hack and an inconvenience to your users but it solves the problem too, albeit I would never recommend to use this solition.</li> </ol>"},{"location":"how_to/change_openapi_schemas/rename_a_field_in_schema/","title":"Rename a field in schema","text":"<p>Let's say that we had a \"summary\" field before but now we want to rename it to \"bio\".</p> <ol> <li>Rename <code>summary</code> field to <code>bio</code> in <code>data.head.users.BaseUser</code></li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn.structure import (\n    VersionChange,\n    schema,\n    convert_response_to_previous_version_for,\n    convert_request_to_next_version_for,\n    ResponseInfo,\n    RequestInfo,\n)\nfrom data.head.users import BaseUser, UserCreateRequest, UserResource\n\n\nclass RenameSummaryIntoBioInUser(VersionChange):\n    description = (\n        \"Rename 'summary' field into 'bio' to keep up with industry standards\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser).field(\"bio\").had(name=\"summary\"),\n    )\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def rename_bio_to_summary(request: RequestInfo):\n        request.body[\"summary\"] = request.body.pop(\"bio\")\n\n    @convert_response_to_previous_version_for(UserResource)\n    def rename_bio_to_summary(response: ResponseInfo):\n        response.body[\"bio\"] = response.body.pop(\"summary\")\n</code></pre> </li> <li> <p>Regenerate the versioned schemas</p> </li> </ol>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This guide provides a step-by-step tutorial for setting up automatic API versioning using Cadwyn. I will illustrate this with an example of a User API, where we will be implementing changes to a User's address. You can also see the advanced version of the service from this tutorial here.</p> <p>Adding a new API version in Cadwyn consists of three main steps:</p> <ol> <li>Make the breaking change</li> <li>Use Cadwyn to describe how to revert the breaking change</li> <li>Use Cadwyn to generate schemas and routes that existed before the breaking change</li> </ol> <p>In this guide, we'll prepare an environment for working with Cadwyn effectively with a basic usage example, make a breaking change, and then show how Cadwyn can help us keep the old API versions untouched.</p>"},{"location":"quickstart/going_back_in_time_before_the_breaking_change/","title":"Going back in time before the breaking change","text":"<p>We need to create a migration to handle changes between these versions. For every endpoint whose <code>response_model</code> is <code>UserResource</code>, this migration will convert the list of addresses back to a single address when migrating to the previous version. Yes, migrating back: you might be used to database migrations where we write upgrade migration and downgrade migration but here our goal is to have an app of HEAD version and to describe what older versions looked like in comparison to it. That way the old versions are frozen in migrations and you can almost safely forget about them.</p> <pre><code># versions/v2002_01_01.py\nfrom pydantic import Field\nfrom data.head.users import BaseUser, UserCreateRequest, UserResource\nfrom cadwyn.structure import (\n    schema,\n    VersionChange,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n    RequestInfo,\n    ResponseInfo,\n)\n\n\nclass ChangeAddressToList(VersionChange):\n    description = (\n        \"Change user address to a list of strings to \"\n        \"allow the user to specify multiple addresses\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        # We assume that issubclass(UserCreateRequest, BaseUser) and\n        #                issubclass(UserResource, BaseUser)\n        schema(BaseUser).field(\"addresses\").didnt_exist,\n        schema(BaseUser).field(\"address\").existed_as(type=str, info=Field()),\n    )\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def change_address_to_multiple_items(request: RequestInfo):\n        request.body[\"addresses\"] = [request.body.pop(\"address\")]\n\n    @convert_response_to_previous_version_for(UserResource)\n    def change_addresses_to_single_item(response: ResponseInfo) -&gt; None:\n        response.body[\"address\"] = response.body.pop(\"addresses\")[0]\n</code></pre> <p>See how we are popping the first address from the list? This is only guaranteed to be possible because we specified earlier that <code>min_items</code> for <code>addresses</code> must be <code>1</code>. If we didn't, then the user would be able to create a user in a newer version that would be impossible to represent in the older version. I.e. If anyone tried to get that user from the older version, they would get a <code>ResponseValidationError</code> because the user wouldn't have data for a mandatory <code>address</code> field. You need to always keep in mind that API versioning is only for versioning your API, your interface. Your versions must still be completely compatible in terms of data. If they are not, then you are versioning your data and you should really go with a separate app instance. Otherwise, your users will have a hard time migrating back and forth between API versions and so many unexpected errors.</p> <p>See how we added a migration not only for response but also for request? This will allow our business logic to stay completely the same, no matter which version it was called from. Cadwyn will always give your business logic the request model from the HEAD version by wrapping each request in it.</p>"},{"location":"quickstart/going_back_in_time_before_the_breaking_change/#grouping-version-changes","title":"Grouping Version Changes","text":"<p>Finally, we group the version changes in the <code>VersionBundle</code> class.</p> <pre><code># versions/__init__.py\nfrom versions.v2002_01_01 import ChangeAddressToList\nfrom cadwyn.structure import Version, VersionBundle\nfrom datetime import date\nfrom data import head\n\n\nversion_bundle = VersionBundle(\n    Version(date(2002, 1, 1), ChangeAddressToList),\n    Version(date(2001, 1, 1)),\n    head_schemas_package=head,\n)\n</code></pre> <p>Let's run code generation, run our app, and then take a look at the generated dashboard and openapi schemas:</p> <p> </p> <p>The endpoint above is from the <code>2001-01-01</code> version. As you see, our routes and business logic are for the HEAD version but our openapi has all information about all API versions which is the main goal of Cadwyn: a large number of long-living API versions without placing any burden on your business logic.</p> <p>Obviously, this was just a simple example and cadwyn has a lot more features so if you're interested -- take a look at the how-to and concepts sections.</p>"},{"location":"quickstart/making_the_breaking_change/","title":"Making the breaking change","text":"<p>During our development, we have realized that the initial API design was wrong and that addresses should have always been a list because the user wants to have multiple addresses to choose from so now we have to change the type of the \"address\" field to the list of strings.</p> <pre><code># data/latest/users.py\nfrom pydantic import BaseModel, Field\nimport uuid\n\n\nclass BaseUser(BaseModel):\n    addresses: list[str] = Field(min_items=1)\n\n\nclass UserCreateRequest(BaseUser):\n    pass\n\n\nclass UserResource(BaseUser):\n    id: uuid.UUID\n</code></pre> <pre><code># routes.py\nfrom data.head.users import UserCreateRequest, UserResource\nfrom versions import version_bundle\nfrom cadwyn import VersionedAPIRouter, Cadwyn\nimport uuid\nimport uvicorn\n\ndatabase_parody = {}\nrouter = VersionedAPIRouter()\n\n\n@router.post(\"/users\", response_model=UserResource)\nasync def create_user(payload: UserCreateRequest):\n    id_ = uuid.uuid4()\n    database_parody[id_] = {\n        \"id\": id_,\n        \"addresses\": payload.addresses,\n    }\n    return database_parody[id_]\n\n\n@router.get(\"/users/{user_id}\", response_model=UserResource)\nasync def get_user(user_id: uuid.UUID):\n    return database_parody[user_id]\n\n\napp = Cadwyn(versions=version_bundle)\napp.generate_and_include_versioned_routers(router)\n\nuvicorn.run(app)\n</code></pre> <p>But every user of ours will now have their API integration broken. To prevent that, we have to introduce API versioning. There aren't many methods of doing that. Most of them force you to either duplicate your schemas, your endpoints, or your entire app instance. And it makes sense, really: duplication is the only way to make sure that you will not break old versions with your new versions; the bigger the piece you duplicating -- the safer. Of course, the safest being duplicating the entire app instance and even having a separate database. But that is expensive and makes it either impossible to make breaking changes often or to support many versions. As a result, either you need infinite resources, very long development cycles, or your users will need to often migrate from version to version.</p> <p>Stripe has come up with a solution: let's have one HEAD app version whose responses get migrated to older versions and let's describe changes between these versions using migrations. This approach allows them to keep versions for years without dropping them. Obviously, each breaking change is still bad and each version still makes our system more complex and expensive, but their approach gives us a chance to minimize this complexity. Additionally, it allows us backport features and bugfixes to older versions. However, you will also be backporting bugs, which is a sad consequence of eliminating duplication.</p> <p>Cadwyn builds upon approach so let's continue our tutorial and now try to combine the two versions we created using versioning.</p>"},{"location":"quickstart/setup/","title":"Setup","text":""},{"location":"quickstart/setup/#installation","title":"Installation","text":"<pre><code>pip install cadwyn\n</code></pre>"},{"location":"quickstart/setup/#project-structure","title":"Project structure","text":"<p>The recommended directory structure for cadwyn is as follows:</p> <pre><code>\u251c\u2500\u2500 data    # Any name or structure could be used here\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 head    # This is the `head_schemas_package` and it must be named `head`\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 users.py\n\u2514\u2500\u2500 versions\n    \u251c\u2500\u2500 __init__.py     # Your version bundle goes here\n    \u2514\u2500\u2500 v2001_01_01.py  # Your version changes go here for each new version\n</code></pre> <p>Here is an initial API setup where the User has a single address. We will be implementing two routes - one for creating a user and another for retrieving user details. We'll be using \"int\" for ID for simplicity. Please note that we will use a dict in place of a database for simplicity of our examples but do not ever do it in real life.</p> <p>The first API you come up with usually doesn't require more than one address -- why bother?</p> <p>So we create our file with schemas:</p> <pre><code># data/head/users.py\nfrom pydantic import BaseModel\nimport uuid\n\n\nclass BaseUser(BaseModel):\n    address: str\n\n\nclass UserCreateRequest(BaseUser):\n    pass\n\n\nclass UserResource(BaseUser):\n    id: uuid.UUID\n</code></pre> <p>Then we create our version bundle which will keep track of our API versions:</p> <pre><code># versions/__init__.py\nfrom cadwyn.structure import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom data import head\n\n\nversion_bundle = VersionBundle(\n    HeadVersion(),\n    Version(date(2001, 1, 1)),\n    head_schemas_package=head,\n)\n</code></pre>"},{"location":"quickstart/setup/#generating-versioned-schemas","title":"Generating versioned schemas","text":"<p>Now let's generate the only version of our schemas -- the one we created in the first step:</p> <pre><code>cadwyn codegen versions:version_bundle\n</code></pre> <p>WARNING Cadwyn doesn't edit your imports when generating schemas so if you make any imports from versioned code to versioned code, I would suggest using relative imports to make sure that they will still work as expected after code generation.</p>"},{"location":"quickstart/setup/#generating-versioned-routes","title":"Generating versioned routes","text":"<pre><code># routes.py\nfrom data.head.users import UserCreateRequest, UserResource\nfrom versions import version_bundle\nfrom cadwyn import VersionedAPIRouter, Cadwyn\nimport uuid\nimport uvicorn\n\ndatabase_parody = {}\nrouter = VersionedAPIRouter()\n\n\n@router.post(\"/users\", response_model=UserResource)\nasync def create_user(payload: UserCreateRequest):\n    id_ = uuid.uuid4()\n    database_parody[id_] = {\n        \"id\": id_,\n        \"address\": payload.address,\n    }\n    return database_parody[id_]\n\n\n@router.get(\"/users/{user_id}\", response_model=UserResource)\nasync def get_user(user_id: uuid.UUID):\n    return database_parody[user_id]\n\n\napp = Cadwyn(versions=version_bundle)\napp.generate_and_include_versioned_routers(router)\n\nuvicorn.run(app)\n</code></pre> <p>That's it! Our app is ready to run.</p> <p>Cadwyn has just generated a separate directory with the versioned schemas for us: one for each API version defined in our <code>VersionBundle</code>. If we run the app, we will see the following dashboard:</p> <p></p>"},{"location":"theory/design_decisions/","title":"Design Decisions","text":""},{"location":"theory/design_decisions/#code-vs-runtime-generation","title":"Code vs Runtime generation","text":"<p>Cadwyn needs to generate at least two things: routes for old versions and schemas for old versions. It generates routes at runtime and schemas as code. Routes are generated at runtime to limit the size of the code base and because it's fairly easy to see which routes exist where using swagger. Schemas, on the other hand, change significantly more often and hence generating them using code might limit the number of human errors because any changes will be visible on code review.</p> <p>Python would allow us to do everything at runtime which is fine. But a different programming language would have different constraints so a code-generating Cadwyn might be easier to implement in other languages/technologies too.</p> <p>There are two problems with code generation: every version makes your repository bigger and code reviews might become more involved. For now it feels like they are worth it but the future will show.</p>"},{"location":"theory/design_decisions/#context-variables","title":"Context Variables","text":"<p>Cadwyn uses context variables for its version migration and side effect interfaces which is a big mistake. It introduces so much complexity and causes a huge lack of transparency in the entire framework. Yes, the interfaces will be a tiny bit uglier without context vars but it's worth the simplicity.</p>"},{"location":"theory/how_to_build_versioning_framework/","title":"How to build a versioning framework","text":""},{"location":"theory/how_to_build_versioning_framework/#questions-to-ask-yourself-when-rating-your-framework","title":"Questions to ask yourself when rating your framework","text":""},{"location":"theory/how_to_build_versioning_framework/#how-easy-it-is-to-create-a-version","title":"How easy it is to create a version?","text":"<p>If it is too easy: it is probably a trap. The framework is probably hiding too much complexity from you and will shoot you in the back later. For example, early on we have tried a simple \"copy entire business logic into a separate directory\" approach which made it so simple to add new versions that we added too many of them -- at the end, maintaining and getting rid of these versions has gotten hellishly hard.</p>"},{"location":"theory/how_to_build_versioning_framework/#how-easy-is-it-to-delete-an-old-version","title":"How easy is it to delete an old version?","text":"<p>Your framework must make it as simple as possible to make sure that you can clean up versions cheaply whenever you need to. For example, if your framework tries to minimize the amount of code duplication in your repository by having new routes include old routes within them and new business logic inherit from classes from old business logic, then deleting an old version is going to be painful; oftentimes even dangerous as versions can quickly start interacting with each other in all sorts of ways, turning a single small application into a set of interconnected applications.</p>"},{"location":"theory/how_to_build_versioning_framework/#how-easy-is-it-to-see-the-differences-between-versions","title":"How easy is it to see the differences between versions?","text":"<p>The easier it is -- the better off our users are.</p>"},{"location":"theory/how_to_build_versioning_framework/#what-exactly-do-you-need-to-duplicate-to-create-a-new-version","title":"What exactly do you need to duplicate to create a new version?","text":"<p>The less we duplicate and maintain by hand -- the easier it is to support. However, the less we duplicate -- the more chance there is to break the old versions with new releases.</p>"},{"location":"theory/how_to_build_versioning_framework/#how-easy-is-it-to-notice-accidental-data-versioning","title":"How easy is it to notice accidental data versioning?","text":"<p>Data versioning is an incredibly big problem when versioning your API so if your framework makes it hard to version data -- it's really good!</p>"},{"location":"theory/how_we_got_here/","title":"How we got here","text":"<p>Over the years we have seen so many ways to do API Versioning. In fact, the majority of these ways can be put into an elegant evolution. Let's go through it from the largest level of duplication to the smallest.</p>"},{"location":"theory/how_we_got_here/#types-of-api-versioning","title":"Types of API versioning","text":"<p>There are three ([1], [2]) main ways to version an API, each consequent being less safe but more convenient to both the API clients and maintainers. Essentially they can be classified by which layers of MVC they version.</p>"},{"location":"theory/how_we_got_here/#1-versioning-proxy-which-points-requests-to-versioned-apps","title":"1. Versioning proxy, which points requests to versioned apps","text":"<p>This approach versions all three layers: separate data, separate business logic, separate representation. Essentially you create a completely different app for each version. Your versions are indepent and cannot in any way affect each other. You can make any sorts of changes in future versions without worrying about breaking the old ones.</p> <p>This approach is the most expensive to support but if breaking old functionality is unacceptable and if you need to support a small number of versions (1-3), then this option is viable.</p> <p>Note that this is essentially data or application versioning, not API versioning anymore. If it is impossible for your user to freely move between API versions (back and forth), then you are probably doing a bit of data versioning yourself. It can simplify your app's logic but will significantly inconvenience your users because they will not be able to easily switch API versions without waiting for your team to help. Additionally, a single client will never be able to use two versions at the same time. At least not easily.</p> <p>Mostly used in older-style apps or in critical infrastructure where no mistakes are permitted</p>"},{"location":"theory/how_we_got_here/#2-one-router-which-points-requests-to-versioned-controllers","title":"2. One router, which points requests to versioned controllers","text":"<p>This approach versions business logic and representation layers while leaving data layer the same. You still have to duplicate all of your business logic but now your clients will be able to migrate between versions easily and you will be able to share some of the code between versions, thus lowering the amount of things you would need to duplicate.</p> <p>The problem with this method is that any refactoring will most likely have to happen in all versions at once. Any changes in the libraries they depend on will also require a change in all versions. When the number of versions starts to rise (&gt;2), this becomes a significant problem for the performance and morale of API maintainers.</p> <p>This is also the approach we have originally started with. It is likely the worst one out there due to its fake simplicity and actual complexity. In the long run, this approach is one of the hardest to support but most importantly: it's probably the hardest to migrate from.</p> <p>Popular in .NET environment and is likely the first choice of any API due to the simplicity of its implementation</p>"},{"location":"theory/how_we_got_here/#3-one-router-shared-controllers-which-respond-with-versioned-representations","title":"3. One router, shared controllers, which respond with versioned representations","text":"<p>This approach versions only the API itself. The business logic and data below the API is the same for all versions (with rare exceptions) so API maintainers have the pleasure of maintaining only one API version while users have the added benefit that non-breaking featurees and bugfixes will automatically be ported to their version. This is the only method that allows you to support a large number of versions because it has the least amount of duplication of all methods. This is usually accomplished by adding a separate layer that builds responses out of the data that your service returns. It can be a separate service, a framework, or just a set of functions.</p> <p>Note that in this method, the usage of data versioning now becomes an inconvenience to both API users and maintainers. See, when you have a single business logic for all versions, you might need additional conditionals and checks for versions where data structure or data itself has changed. That is in addition to pre-existing incoveniences for the users. However, sometimes it might still happen so our goal is to minimize the frequency and impact of data versioning.</p> <p>Popular in API-First tech giants that have to support backwards compatibility for a long time for a large number of clients</p> <p>Note that this approach actually has two important subtypes:</p>"},{"location":"theory/how_we_got_here/#i-duplication-based-response-building","title":"i. Duplication-based response building","text":"<p>The simplest possible builder: for each API version, we define a new request/response builder that builds the full response for the altered API routes or migrates the user request to the latest version. It is incredibly simple to implement but is not scalable at all. Adding values to all builders will require going through all of them with the hope of not making mistakes or typos. Trying to support more than 8-12 versions with this approach will still be challenging.</p> <p>We might think of smart ways of automating this approach to support a larger number of versions. For example, to avoid duplicating the entire builder logic every time, we can pick a template builder and only define differences in child builders. Let's pick the latest-version builder as template because it will never be deprecated deleted and our developers will have the most familiarity with it. Then we need to figure out a format to define changes between builders. We can remove a field from response, add a field, change the value of a field somehow, and/or change the type of a field. We'll need some DSL to describe all possible changes.</p> <p>Then we start thinking about API route differences. How do we describe them? Or do we just duplicate all routes? Do we maybe use inheritance? No matter what we do, we'll eventually also come to a DSL, which is why some tech giants have chosen approach ii.</p> <p>A code generation yaml-based version of this approach was used at SuperJob.</p>"},{"location":"theory/how_we_got_here/#ii-migration-based-response-building","title":"ii. Migration-based response building","text":"<p>This is effectively an automated version of approach i. It has the minimal possible amount of duplication compared to all other approaches. Using a specialized DSL, we define schema migrations for changes in our request and response schemas, we define compatibility gates to migrate our data in accordance with schema changes, and we define route migrations to change/delete/add any routes.</p> <p>This is the method that Stripe, Linkedin, and Intercom have picked and this is the method that Cadwyn implements for you.</p>"},{"location":"theory/literature/","title":"Literature","text":"<p>During Cadwyn's development, I went through countless resources on API Versioning. The following are the most unique and effective ones I could find.</p>"},{"location":"theory/literature/#cadwyn-like-api-versioning","title":"Cadwyn-like API Versioning","text":""},{"location":"theory/literature/#articles","title":"Articles","text":"<ul> <li>https://stripe.com/blog/api-versioning</li> <li>https://www.intercom.com/blog/api-versioning/</li> <li>https://getconvoy.io/blog/rolling-versions</li> <li>https://keygen.sh/blog/breaking-things-without-breaking-things/</li> <li>https://engineering.linkedin.com/blog/2022/-under-the-hood--how-we-built-api-versioning-for-linkedin-market</li> <li>https://rescale.com/blog/api-versioning-with-the-django-rest-framework/</li> </ul>"},{"location":"theory/literature/#projects","title":"Projects","text":""},{"location":"theory/literature/#python","title":"Python","text":"<ul> <li>https://github.com/binnev/djangorestframework_versioning</li> </ul>"},{"location":"theory/literature/#golang","title":"Golang","text":"<ul> <li>https://github.com/sjkaliski/pinned</li> <li>https://github.com/subomi/requestmigrations</li> </ul>"},{"location":"theory/literature/#ruby","title":"Ruby","text":"<ul> <li>https://github.com/phillbaker/gates</li> <li>https://github.com/keygen-sh/request_migrations</li> </ul>"},{"location":"theory/literature/#php","title":"PHP","text":"<ul> <li>https://github.com/lukepolo/laravel-api-migrations</li> <li>https://github.com/tomschlick/request-migrations</li> </ul>"},{"location":"theory/literature/#overview-articles-on-api-versioning","title":"Overview articles on API Versioning","text":"<ul> <li>https://smartlogic.io/blog/2012-12-12-developing-an-api/</li> <li>https://thenewstack.io/tricks-api-versioning/</li> <li>https://studygyaan.com/django/versioning-api-in-django-rest-framework</li> </ul>"},{"location":"theory/literature/#other-articles-on-api-versioning","title":"Other articles on API Versioning","text":"<ul> <li>https://www.postman.com/api-platform/api-versioning/.</li> <li>https://www.xmatters.com/blog/blog-four-rest-api-versioning-strategies</li> <li>https://www.opslevel.com/resources/the-ultimate-guide-to-microservices-versioning-best-practices</li> <li>https://github.com/dotnet/aspnet-api-versioning</li> <li>https://habr.com/ru/companies/superjob/articles/577650/</li> <li>https://mikehelmick.medium.com/django-rest-framework-better-api-versioning-with-semantic-versioning-d93908613dea</li> </ul>"}]}